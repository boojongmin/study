켄트벡의 구현패턴 - 읽기 쉬운 코드를 작성하는 77가지 자바 코딩 비법

- 패턴
- 가치와 원칙
- 동기
메소드 <-(로직의 분화)- 행위 <-(유사한 로직)-클래스-(다른데이터)->상태-(여러개의 데이터)->컬렉션
<프레임워크>

클래스: 왜, 어떻게 클래스를 생성해야 햐는지, 클래스에서 어떤 식으로 로직을 표현해야 하는가에 관한 패턴
상태: 상태를 저장하고 읽어오는 데 관한 패턴
행위: 로직, 특히 여러 개의 수행 경로(alternative path)를 표현하는 패턴
메소드: 메소드를 작성하는 데 관한 패턴, 나중에 내 코드를 읽을 사람은 내가 작성한 메소드 이름을 보며 어떤 생각을 할 것인가?
컬렉션: 컬렉션을 선정하고 사용한 데 관한 패턴
발전하는 프레임워크: 애플리케이션이 아닌 프레임워크를 작성할 때는 어떤 식으로 패턴을 변화시켜 사용해야 하는가?

읽기 쉬운 코드란 읽기 쉬운 글을 쓰는 것과 같다.
대상 독자를 저아고 명확한 전체 구조를 갖고, 전체 줄거리를 생각해서 세부 묘사를 해야한다.

프로그래머는 혼자 생각하면서 보내는 시간이 너무 많으므로, 다른 사람의 관점에서 코드를 바라보려 시도하는 것 자체가 커다란 변화이다.
컴퓨터가 이 코드를 어떻게 처리할까 + 내 생각을 다른 사람에게 어떻게 전달할까

언어에서 제공하는 각 요소들이 어떤 문제를 해결하기 위해 설계된 것인지 알아야한다. 구현 패턴은 프로그래밍을 할 때 빈번히 발생하는 문제들과, 그 문제들에 대한 해결책을 자바로 제시한 것

인생이 70년이라고할때 우리 인생은 20억초에 불과하다...

### 01 소개

코드를 통한 커뮤니케이션의 단계
1. 생각을하며 프로그래밍-본능에 의해 코딩하는 것을 멈추고 내가 어떤 생각을 하고 있는지 살펴볼 수 있는여유
2. 다른 사람의 중요성을 인식
3. (2)를 인식후 그 생각을 실천으로 옮기기.


디자인패턴 - 보통 객체 간의 관계 설정, 하루에 몇 차례하는 결정
구현 패턴 - 몇 초에 한번씩 하게 되는 결정, 어떤 경우 어떤 언어의 구성 요소를 사용할지에 대한 것과, 그 결정에 대해 나중에 그 코드를 읽은 다른 이가 어떤 결론을 내릴 것인지에 대해.


### 02 패턴
대부분의 프로그램에는 다음과 같은 법칙이 적용된다.
- 프로그램을 새로 짜는 경우보다는 기존 프로그램을 읽는 경우가 많다.
- 프로그램에 있어 '완성'은 없다. 최초에 프로그램을 개발하는 데 드는 노력보다는 이후 프로그램을 수정하는 데 들어가는 노력이 더 크다.
- 프로그램 구조는 몇 가지 상태와 제어 흐름 개념으로 결정된다.
- 프로그램을 읽는 사람은 개념과 더불어 세부 사항까지도 이해해야 한다. 세부 사항을 이해해야 전체 개념에 대한 그림을 그릴 수 있고, 한편 전체 개념을 이해해야 세부적인 구현 내용을 이해할 수 있기 때문이다.

@패턴을 사용하는 것은 처음에 답답할 수 있다. 하지만 패턴은 시간과 에너지를 줄여준다.(매번 어떻게 할지 고민하는 것 보다, 평상시 습관대로 하는 편이 훨씬 적은 노력이 든다. - 이래서...인간들에게 관성이 생길수도...)
@패턴은 절대적인 진리가 아니므로, 사람의 의사 결정을 돕는 도구 정도로 생각하고 상황에 딸 패턴을 적절히 변화 시켜 사용해야한다.

### 03 프로그래밍 이론
의사 결정 사항에 영향을 미치는 동력
- 가치(value): 모든 프로그래밍에 적용되는 주제. 프로그램을 잘 짜는 사람은 타인과의 커뮤니케이션을 중시하고, 코드의 과도한 복잡성을 피하면서도 유연성 있는 코드를 작성. 커뮤니케이션, 단순성, 유연성의 가치는 모든 프로그래밍을 할 때 내리는 모든 의사 결정에 영향을 미친다.
- 원칙(principle): 가치처럼 언제나 적용되는 것은 아니지만 많은 패턴에서 사용된다. 항상 중요하지만 때로는 직접 적용하기 어려운 가치와, 적용법은 명확하지만 조금은 지엽적인 패턴 사이의 가교 역할을 하는 것이 역할. 패턴들간에 결정이 애매한 상황에서 원칙을 이해한다면 훌륭한 해결책을 찾을 수 있다.

무엇인가를 동의하지 않는다면 어느 수준(layer)에서 차이가 있는지 파악하는 것이 중요하다. 단순 괄호를 가지고 논쟁하는데 그 내면적으로 원칙을 동의하지 않은 상태였는데 논쟁이 끝날 수가 없다.

#### 가치
- 커뮤니케이션
- 단순성
- 유연성

-> 최고의 프로그래머는 확장성을 고려해서 프로그램을 짜지만, 불필요한 요소를 사용하지 않으며, 읽고 이해하기 쉬운 프로그램을 짠다.

##### 커뮤니케이션
코드를 쉽게 이해하고, 수정하고 사용할 수 있다면 그 코드는 개발자와 커뮤니케이션을 하고 있다고 이야기할 수 있다.
컴퓨터 뿐만 아니라 타인을 고려해서 프로그램을 짜면, 애해가 쉽고 깔끔, 더 효율적이 되고 생각은 명확해진다. 새로운 관점에서 코드를 바라보게 된고, 스트레스가 줄어들며, 다른 사람도 볼 만한 코드가 만들어진다.
경제적으로도 효과가 높다. - 유지보수.

@"다른 사람이 이걸 보면 어떤 생각을 할까?"라는 생각을 하면서 코딩!!

##### 단순성
(그래프의 원본에서 불필요한 점을 지운 그래프는 원본에 비해 참신하고 이해하기도 훨씬 쉽다.)

복잡도를 낮추면(단순하게하면) 커뮤니케이션이 쉬워진다(코드를 읽기 쉬워진다). 유지보수시 복잡성이 높아지면 손을 대기 어려워진다. 프로그래밍을 하면서 불필요한 코드를 제거해 나가야한다.

프로그램을 최대한 단순화
의미없는 코드는 모두 제거
설계시 과도한 요소 모두 제거
요구사항을 분석해서 꼭 필요한 사항만 뽑아내기 등.

단순성은 커뮤니케이션의 증가를 부른다 하지만 과도한 단순화가 커뮤니케이션을 저해할 수 있다. 이때는 커뮤니케이션에 더 신경을 써서 프로그래밍을 한다.

##### 유연성
비효율정인 코딩이나 설계를 정당화해주는 가치
(프로그램 수정이 유연해야한다.)
ex) 상수값을 직접 코딩하는게 아니고, 프로퍼티 파일을 만들어서 파일을 읽고 파싱해서 상수를 할당. -> 복잡성이 증가된다. 하지만 이 프로그램은 유연하다. 유연성을 통해 프로그램 수정이 쉬워진다.

유연성이 있으면서 당장 이득을 얻을 수 있는 패턴을 사용. 앞으로 이득을 얻을 수 있을지 불확실한 패턴의 경우에는 사용을 보류했다가 정말 필요할 때 사용하라.

유연성은 복잡성을 증가 -> 위의 프로퍼티 예
단순성은 유연성을 증가 -> 프로퍼티를 사용하는 옵션을 제거하면 단순해지면서 프로그램 수정이 용이해진다.

#### 원칙
원칙을 이해하고 있다면, 패턴을 사용하는 근본적인 이유에 대해 알 수 있으므로 새로운 상황에 부딪혔을 때 적절히 대처할 수 있고, 새로운 패턴을 만들수 있다.

##### 지역적 변화
코드를 수정할 때 함께 바꿔야 하는 부분을 최소화하라. - 프로그램 수정비용 최소화

##### 최소 중복

중복은 실제 코드에 나타나기 전까지 예측하기 어렵고, 발생한 후에도 그 존재가 분명치 않다. 어떤 경우는 중복을 제거하기 어려울 수도 있다. 
-> 중복을 절대로 피해야할 요소로 보기보다는 코드 수정 비용을 높이는 위험 요소로 보는 것이 좋다.

중복을 없애는 방법
프로그램을 여러 작은부분으로 나눈기.(짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지)

##### 로직과 데이터의 결합
데이터와 (그 데이터를 처리하는) 로직을 밀접하게 배치하라
(가급적 같은 메소드 혹은 같은 객체 내에, 최소한 같은 패키지 내부에)
프로그램을 수정할때 로직과 데이터를 모두 고쳐야 할 경우가 많다. 따라서 로직과 데이터가 함께 있다면 프로그램을 수정하더라도 그 영향이 일정 영역에 머물게 된다.

##### 대칭성(symmetry)
대칭적인 존재. ex) add() <-> remove(), 같은 파라메터를 쓰는 여러 개의 메소드
대칭성을 찾아내면 명확하게 표현해주면 상대적인 코드는 쉽게 이해가 가능하기 때문에 가독성이 증가된다.

대칭성이란 시각적으로 표현할 수 없는 개념적인 대칭성일 경우가 많다.
대칭성이란 하나의 아이디어를 프로그램 전체에서 일관된 방식으로 표현하는 통일성이라고 할 수 있다

대칭성을 찾아서표 표현하면 코드의 중복을 제거할 수 있다. 

##### 선언적 표현
명령형 프로그래밍(imperative programming)에서는 프로그램의 수행흐름을 따라가야한다. 즉, 컴퓨터의 수행 상태를 생각하면서, 제어 흐름과 데이터 흐름을 추적해야 프로그램을 제대로 이해할 수 있다.
수행 순서가 중요한 구문이나 조건부 구문이 없는 일반 구문의 경우, 선언적 표현을 통해 코드를 작성하는 것이 이해가 쉽다.

##### 변환율
변환율이 다른 로직과 데이터는 분리.
변환율은 대칭성의 일종으로 시간적 대칭성이다. 
(value, currency -(변하는 부분은 도우미 객체 사용)> new Money(value, currency))
value, currency는 대칭적으로 함께 변하지만 객체내의 다른 필드와는 대칭적이지 않다.
(-_-?)

### 04 동기유발
전체 비용 = 개발 비용 + 유지 비용
이 책은 유지 비용이 많이 드는 상황에서 적용. 유지 비용이 거의 들지 않는 프로젝트라면 다른 종류의 패턴 사용 권유한다.

유지 비용 = 이해 비용 + 수정 비용 + 테스트 비용 + 설치 비용

구현 패턴이 습관화 되면 -> 처음엔 힘들지만...개발이 더 빨라지고 코드 이해가 쉬워져 커뮤니케이션 증가. -> 유지 비용 절감 효과.(코더가 왜 비용 측면에 관심은...흠...나랑 급이 다른갑다 -_-;;)

### 05 클래스

	클래스의 역사는 플라톤이 살았던 시대까지 거슬러 올라간다. 플라토은 현실 세계에 존재하는 것은 클래스의 인스턴스(instance)일 뿐이라고 이야기했다. 플라톤 세계의 클래스는 완벽하지만 현실적이지 못하고, 현 세계에 있는 인스턴스는 존재하기는 하지만 어딘가 불완전하다.
    (오 대박 나도 이런 생각했었는데...감동 ㅋㅋ)

클래스와 객체는 후기 서양 철학의 아이디어를 받아들여서 프로그램을 콜래스와 객체로 구성한 것이다.
클래스: 비슷한 성질을 가진 것을 총칭
객체: 클래스가 구체화된 것

- 클래스: "이 데이터 들은 함께 사용되는데 그에 관련된 로직이 이것이다"라는 이야기를 하고 싶을 때 클래스를 사용한다.
- 단순한 상위클래스 이름: 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다.
 간결성과 표현성 사이에서 고민인 경우는 은유(metaphor)사용 - ex: DrawingObject -(Drwaing은 책의 페이지와 비슷하고 페이지의 각 항목은 그림)-> Figure 
- 한정적 하위클래스 이름: 상위클래스와의 유사점과 차이점을 분명히 드러내는 이름을 사용한다.
클래스 게층의 최상의 클래스와 같은 역할을 하는 하위 클래스에는 단순한 이름을 선택해야한다.
ex) Figure -> ** Handle** -> StretchHandle, TransparencyHandle
- 추상 인터페이스: 인터페이스와 구현을 분리한다.
인터페이스: 구현이 빠진 여러 연산의 집합, 인터페이스를 사용한다면, 구상 클래스(concrete class)를 나중에 얼마든지 바꿀수 있다. 구상 클래스는 컴퓨터가 실제 연산을 하기 전에만 결정하면 된다.
인터페이스 추가에는 비용이 발생되므로 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 사용.
- 인터페이스: 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
자바 인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다"와 같다.
네이밍 원칙2(둘다 객체가 추상인지 구상 객체인지 전달하는게 포인트)
인터페이스는 간결하게 구상 클래스에 구상객체인지 전달. - File - ActualFile, ConcreteFile, FileImpl
구상 클래스를 간결하게 짓고 인터페이스에 I등을 붙이는 방법 - IFile - File
- 버전 인터페이스: 하위 인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다.
인터페이스를 바꾸고 싶고 기존 구현 클래스를 수정하고 싶지 않을때.
```java
interface Command {
  void run();
}
...
interface ReversibleCommand exntends Command {
  void undo();
}
...
Command recent = ...;
if(recent instanceof ReversibleCommand) {
  ReversibleCommand downcasted = (ReversibleCommand) recent;
  downcasted.undo();
}
```
instanceof를 사용하면 코드가 특정 클래스에 제한되므로 유연성이 떨어진다. 버전(대체) 인터페이스는 달갑지 않은 문제에 대한 달갑지 않은 해결책임이다. 확장할 수 없어서 어쩔수 없는 경우 사용
- 추상 클래스: 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
상위 클래스가 런타임에 어떤 하위 클래스로 교체 될지 모른다는 의미에서 추상적이다.
인터페이스는 수정에 비용이 크다, 하지만 추상클래스는 기존 설계를 망가트리지 않고 기본 구현을 사용할 수 있어서 새로운 연산을 추가하기 용이하다.
- 값 객체: 산술 값처럼 동작하는 객체를 사용한다.
자바의 기본형 타잎은 수학적 세계에 속한다(함수형이다). 예를들어, 숫자에 숫자를 더하는 경우 값이 변하는게 아니고 새로은 값을 만든다.
함수형스타일 연산은 상태를 변화시키지 않으며 새로운 값을 생성. 일시적이더라도 고정적인 상황을 표현하고 싶다면 함수형 스타일이 적절하고, 상황이 변하는 경우라면 상태(state)를 사용하는 편이 낫다.
프로시저 인터페이스는 함수 인터페이스에 비해 자주 사용되지만 호출순서가 인터페이스의 일부가 된다. 프로시저 호출 순서에 대한 묵시적 인터페이스가 변경될 경우, 겉보기에 변화가 예측하기 어려운 많은 문제점을 가져온다.
함수형(수학적표현법)의 장점은 순서가 문제가 되는 경우가 드물다는 것. 
????----------------수학적 표기법은은 코드 한줄 한줄이 참이다.작은 수학의 세계를 만든후, 변화하는 상태를 갖고 있는 객체를 통해 관리하는 것이 좋다.-----------------------????
```java
class Transaction {
    int value;
    Transaction(int value, Account credit, Account debit) {
      this.value = value;
      credit.addCredit(this);
      debit.addDebit(this);
    }
}
```
값 스타일 객체(변화하는 상태를 지닌 객체가 아닌 정수와 같은 객체)를 구현하려면, 상태를 가지고 있는 세계와 값으로만 구성된 세계를 구별해야한다.
위의 예에서 Transcation은 값 스타일 객체이고 Account는 변화하는 상태를 가진 객체이다.
값스타일의 객체에서는 생성자에서만 모든 상태를 설정해야한다.
값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다.
-> 값 스타일 객체를 사용할 때의 문제점은 성능이다.
- 특화: 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다.
코드 가독성 증가, 기존 코드가 새로운 요구사항을 처리할 수 있는지 판단할 수 있다.
연산간의 유사점과 차이점을 부각시키는 방향으로 코드를 작성하면, 프로그램을 읽고 사용하고 수정하기 쉬워진다.
(간단한 변형 - 상태만 변경, 복잡한 변형 - 로직 자체를 바꾸는 것)
로직과 데이터의 경계가 분명하지 않다. 플래그는 boolean이지만 제어흐름에 영향을 미치고, 도우미 객체는 필드에 저장할 수 있다.
- 하위클래스: 1차원적 변환은 하위클래스를 사용해서 표현한다.
"이 객체는 상위 클래스와 같다. 이 부분만 제외하면..."이라는 의미와 같다.
상속을 사용할때 문제점
하위 클래스를 되돌리기가 쉽지 않다.
하위 클래스를 이해하기 위해서는 상위 클래스를 이해해야한다.
하위 클래스가 상위클래스 세부 구현 특성에 의존할 수 있으므로 상위클랫의 수정이 위험해진다.
클래스 상속 계증이 복잡해지면서 위의 모든 문제가 심화된다.
병렬 클래스 계층을 사용하는 경우 클래스 계층간 암묵적 의존관계를 형성하게된다.(두개의 상위 클래스가 있는 경우 각각의 상위 클래스는 하위클래스가 있게 된다. 이 하위 클래스는 다른 클래스 계층에 대응되는 상황이 만들어진다.) 이는 일종의 중복이다.
하위 클래스를 올바르게 사용하기 위한 키 포인트는 상위클래스의 로직을 여러개의 메소드로 잘개 쪼개는 것.
상위클래스 메소드가 너무 크다면, 상위 클래스의 메소드를 복사해서 수정한다. 하지만 이러는 경우는 상위/하위 클래스간 암묵적 의존 관계가 생긴다. 이 경우 유지보수에 문제가 생기므로 신중을 가해야한다.
하위 클래스는 동적으로 변화하는 로직을 나타낼 수 없기 때문에, 객체를 생성할 때 그 객체의 목적을 알아야 하며 이는 이후에 바뀔 수 없다. 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용.
- 구현자(implementor): 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다.
(내용이 구현자란 주제하고 생뚱맞는 느낌은...)
객체지향 프로그램에서는 선택을 표현하기 위해 주로 다형적 메시지(polymorphic message)를 사용.
프로시저 표현에 비해 객체와 메시지를 사용하는 방식은 프로그래머의 의도와 구현을 분리해서 좀더 명확히 프로그래머의 의도를 나타낸다. 그리고 미래에 발생된 확장에대해서도 수용할 수 있게 되었다. -> 표현의 명확성과 유연성을 통해 객체 지향 언어는 프로그래밍 언어의 패러다임을 교체했다.
- 내부 클래스: 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다.
간단히 상위 클래스를 약간 수정하는 경우 유용
내부 클래스를 감싼 클래스(enclosing case)에 대한 정보를 암묵적으로 전달 받는다. 이는 클래스간의 관계를 명시적으로 정하지 않으면서도 감싼 클래스의 데이터를 접근할 수 있는 기법이다.
```java
public class InnerClassExample {
	private String field;
    public class Inner {
    	public String example(){
        	return field;
        }
    }
    @Test publicvoid passes() {
    	field = "abc";
        Inner bar = new Inner();
        assertEquals("abc", bar.example());
    }
}
```
위의 경우 내부 클래스를 명시적으로 선언하는 경우에도 인자 없는 생성자를 가질 수 없다.(why????????????????????????) 리플렉션을 사용해서 인스턴스를 만든다면 내부 클래스의 이러한 점이 문제가 될 수 있다.

```java
public class InnerClassExample {
    public class Inner {
        public Inner() {}
    }

    @Test(expected = NoSuchMethodException.class)
    public void innerHasNoArgConstructor() throws Exception {
//       Inner.class.getConstructor(null);
        Inner.class.getConstructor(new Class[0]);
    }

}
```

생성클래스의 인스턴스와 완전히 분리된 내부 클래스를 사용하려면, 내부 클래스를 static으로 선언하면 된다.
- 인스턴스별 행동(instnace-specific behavior): 인스턴스에 따라 로직에 변화를 준다.
비추!! 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 편이 좋다.(커뮤니케이션등 비용이 커진다.)
- 조건문: 명시적 조건에 딸 로직에 변화를 준다.
조건문의 수가 많을수록 프로그램의 안정성이 떨어지는 경향이 있다.
ex)
```java
public void display() {
	switch(getType()) {
    	case RECTANGLE:
        .....
    }
}
public boolean contains(Point p) {
	switch(getType()){
    	case RECTANGLE:
        ...
    }
}
```
위의 예처럼 코드의 암묵적으로 의존성이 발생된다.(하나를 수정하면 다른것도 수정. 다른 개발자에게도 해당 내용을 전체적으로 공유해야하는 문제가 발생)
이 문제는 하위 클래스나 위임을 사용해 조건문을 메시지로 바꾸면 해결 할 수 있다.
중복되는 조건부 로직이나 분기문의 결과에 따라 로직이 달라지는 경우, 보통 명시적인 로직 대신 메시지를 사용하는 것이 좋다. 또한 자주 변하는 조건부 로직의 경우 메시지를 사용하면 다른 분기문에 대한 영향을 최소화하면서 분기문을 단순화할 수 있다.
조건문은 단순성과 지역성(하나의 클래스만 수정)에 장점이 있지만 광범위하게 사용되는 경우 문제가 될 수 있다.
- 위임(delegation): 여러 종류의 객체 중 하나에 위임해서 로직에 변화를 준다.
각 인스턴스에서 다른 로직은 수행하도록 하는 방법으로는 위임(몇 가지 객체 중 하나를 선택해서 작업을 미루는 것)이 있다.

```java
public void mouseDown() {
	switch(getTool()) {
    	case SELECTING : 
            //...
            break;
        case EDITING_TEXT:
        	//...
            break;
        default: break;
    }
}
```
```java
public void mouseDown() {
	getTool().mouseDown();
}
```
새로운 툴을 추가해도 기존 코드를 수정해야하고, 조건문의 중복등으로 인해 도구를 새로 추가하기가 어렵다.(mouseUp(), mouseDown()... hm..............)
메소드가 여러 클래스에 분산되어 구현되므로 코드 읽기는 어려워 졌다.
- 플러그인 선택자(pluggable selector): 리플렉션을 이용한 메소드 호출로 로직에 변화를 분다.
한두 개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스 안에 들어가도 좋은 경우 사용.

```java
String name;
public void runTest() throws Exception {
	Class[] noArguments = new Class[0];
    Method method = getClass().getmethod(name, noArguments);
    method.invoke(this, new Object[0]);
}

```
플러그인 선택자 사용에 따르는 비용은 상당하므로, 그 비용을 정당화 할 수 있는 일부 어려운 문제에만 제한적으로 사용해야 한다.
- 익명 내부 클래스: 필요한 메소드에서 한두 개의 메소드만 오버라이드하는 객체를 만들어서 사용한다.
API가 매우 간단하거나 상위 클래스가 대부분의 구현을 담당하고 있어 내부 클래스를 쉽게 구현할 수 있을때 효과적, 익명 내부 클래스를 사용하는 클래스를 읽는데 방해가 되므로 가급적 짧아야 한다.
단점.
인스턴스에서 사용할 코드가 어떤 것인지 알고 있어야한다.
인스턴스 생성 후에는 수정할 수 없다.
별도로 테스트하기 어려워 복잡한 로직에 적합치 않다.
클래스 이름을 사용할 수 없으므로 이를 통해 프로그래머의 의도를 전달할 수 없다.
- 라이브러리 클래스: 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.
단점.
메소드 수가 많아질 경우 
모든 로직을 정적 메소드로 구현하면 객체지향 프로그래밍의 가장 큰 장점(공유데이터를 전용 네임 스페이스를 사용하여 표현해서 로직은 단순화하는것 <-이게 왜 가장 큰 장점이지???)을 잃게 되므로 가능하면 라이브러리 클래스는 객체로 변환하는 것이 좋다.

라이브러리 클래스를 점진적으로 객체로 바꾸기 위해서는 정적 메소드를 인스턴스 메소드로 바꾸면 된다. 처음에는 정적 메소드가 인스턴스 메소드에 위임하는 방식을 사용해서 같은 인터페이스를 유지하는 것이 좋다.

### 06 상태
상태의 사용에 대해 전달하는 패턴에 대하 알아보는 장.
객체는 외부에 드러나는 행위(behavior)와 행위를 지원하기 위한 상태(state)를 묶어주는 편리한 단위이다.

- 상태: 시간에 따라 변화하는 값을 사용하여 연산한다.
함수형 언어는 상태의 개념 없다. 인간의 뇌는 시간에 따라 변하는 상태에 익숙하기 때문에 함수형의 상태 없음은 인기를 얻지 못했다(라고 저자가 말함.)
객체지향 언어는 매우작은 단위로 쪼갠후, 각각에 대해 엄격한 접근 권한을 적용해서 기존보다 상태에 대한 관리를 더 용이하게 해준다.
효과적으로 상태를 관리하기위한 키 포인트는 유사한 상태를 묶어서 관리하고 각 상태를 별도로 관리하느 ㄴ것.
두가지 상태가 유사한지 알 수 있는 단서 1)동일한 연산 안에서 사용, 2) 동일한 시점에 생성/소멸되는지 확인.
- 접근: 상태에 대한 접근을 제한해서 유연성을 조절한다.
프로그래밍 언어는 저장된 값에 대한 접근(accessing stored value)과 계산(invoking computation)으로 나눌수 있다.
메모리 접근: 현재 저장된 값을 반환하는 일종의 계산
계산: 아직 저장되지 않은 메모리 값을 읽는 일종의 값 접근
뭘 계산하고 저장할지 정하는 것은 프로그램의 가독성, 유연성, 성능에 영향을 미친다.
객체 사이에 공용필드(public field)는 객체간의 접근의 용이성을 위해 객체간 독립성을 포기하는 것은 바람직하지 않다. 
- 직접 접근: 객체 내의 상태를 직접 접근한다.
x = 1;
장점: 표현의 명확성
단점: 수정시 변수를 접근하는 모든 부분을 고쳐야하기 때문에 유연성이 떨어짐, 직관적인 코드가 아니게된다.(ex - doorRegister = 1; -> door.open())
- 간접 접근: 좀더 나은 유연성을 위해 메소드를 통해 상태에 접근한다.
메소드 호출을 통해 상태 변화를 숨길 수도 있다.(명확성과 직접성을 희생함)
(켄트백은)클래스 내부에서는 직접 접근을 허락하고 클래스 외부에서는 간접 접근을 사용을 추천한다.
간접 접근이 유용한 경우는 2개 이상의 데이터 간에 의존 관계가 존재하는 경우이다.
```java
void setWidth(int width) {
	this.width = width;
    area = width * height;
}
```
- 공용 상태: 클래스의 모든 인스턴스에 적용되는 상태는 필드에 저장한다.
(자꾸 헤갈리네;; 필드는 전역변수!!!)
- 가변 상태: 같은 클래스의 인스턴스마다 다른 상태를 유지해야 할 경우 상태를 맵에 저장한다.
(hm... -_- 책내용 더 살펴보고 정리해야할듯 ;;, 그냥 skip)
- 외재 상태(Extrinsic State): 객체와 연동된 특수 상태는 상태의 사용자가 소유하는 맵에 저장한다.
(skip -_-;;)
- 변수: 변수는 상태 접근에 필요한 네임스페이스를 제공한다.
skipp
- 지역 변수: 지역 변수는 단일 범위 내에서만 유효한 상태를 저장한다.
지역 변수는사용되는 직전에 최소 범위 내에서 선언.
지역변수의 역할
 - 컬렉터: 이후 사용을 위해 정보를 모은다. return 되는 경우 result, results로 네이밍 추천
 - 카운터: 특정 객체의 수를 저장하는 특수 컬렉터
 - 설명: 복잡한 표현을 해야하는 경우, 표현 내용을 지역변수에 저장하면 독자가 쉽게 이해할 수 있다 -> 이는 도우미 메서드로 변경할 수 있다.
 - 재사용: 값이 바뀌지만 기존 값을 다시 사용해야 하는 경우.
```java
for(Clock each: getColocks()) each.setTime(System.currentTimeMillis());
...
long now= System.currentTimeMillis());
for(Clock each: getColocks()) each.setTime(now);
```
 - 원소: 컬렉션의 원소를 저장하기 위해 사용. 위의 each처럼 each는 컬렉션의 원소임을 나타내는 단순한 지역 변수 이름이다. 중첩 루프인 경우 'each + 컬렉션(단수)명'을 사용하면 된다.

- 필드: 필드는 객체가 생성될 때부터 소멸될 때까지 상태를 저장한다.
필드 변수의 역할
 - 도우미: 도우미 필드는 객체의 여러 메소드에서 사용하는 객체를 저장한다. 여러 메소드에서 중복되는 파라메터가 있다면 파라미터를 도우미 필드로 바꾸고 생성자에서 필드를 설정하는 방법을 고려할 만하다.
 - 플래그: "객체가 두 가지 다른 방식으로 동작함"을 의미
 - 전략: 객체의 연산을 하는 다른 방법이 있음을 나타내는 경우, 그부분을 수행하는 객체를 필드에 저장. 생성자에서 전략필드를 설정, 객체의 생명기간 동안 만약 연산 방법이 바뀐다면 수정자 메서드를 제공하라.
 - 상태: 객체의 행위 양식을 결정한다는 점에서 전략 필드와 비슷하지만 상태 필드는 스스로 다음 상태를 설정한다. 전략 필드는 다른 객체에 의해 설정된다. 상태와 상태 전이가 한 곳에서 표현되지 않으므로, 이런 방식으로 구현한 상태 기계 코드는 읽기 어렵다. 그러나 상태 사용이 그리 복잡하지 않은 경우라면 괜찮다.
 - 부속(component): 부속 필드는 해당 객체가 소유하는 객체나 데이터를 저장한다.
- 파라미터: 파라미터는 메소드가 활성화된 동안 상태를 전달한다.
```java
//단일 파라메터는 약한 의존성을 생성한다.
Server s = new Server();
s.a(this);
s.b(this);
s.c(this);
s.d(this);
//참조를 통해 의존성 감소.
Server s = new Server(this);
s.a();
s.b();
s.c();
s.d();
```
- 수집 파라미터(collecting parameter): 여러 개의 메소드를 통해 복잡한 결과를 얻기 위해 파라미터를 전달한다.
컬렉션을 통한 결과 값을 반환할때 단순한것 외에는 파라메터를 전달해서 결과를 수집하는게 더 직관적이다.
```java
asList(){
	List result = new ArrayList();
    addTo(results);               // <= 요놈처럼.
    return results;
}
addTo(List elements) {
	elements.add(getValue());
    for(Node each: getChildren())
    	each.addTo(elements);
}
```
- 옵션 파라미터: 파라미터가 전달 되지 않는 경우 기본 파라미터를 사용, 기본 파라 미터외에는 옵션 파라메터. 기본 파라미터는 앞에, 옵션 파라미터는 뒤에 작성
```java
public ServerSocket()
public ServerSocket(int port)
public ServerSocket(int port, int backlog)
```
자바의 경우 위치에 따라 파라미터를 구별하므로, 위로 같은 용법을 사용해서 옵션 파라미터를 나타낼 수 있다.위와 같은 방식을 망원경에 비유해서 망원경식 파라미터 패턴이라고 불린다.
- 가변 인자: 자바의 varargs 사용
[참조](http://viralpatel.net/blogs/varargs-in-java-variable-argument-method-in-java-5/)
- 파라미터 객체: 자주 사용하는 긴 파라미터 목록은 객체로 만들어서 통합한다. 
- 상수: 변하지 않는 상태는 상수로 저장한다.
- 역할 제시형 작명: 변수 이름은 연산에서의 역할을 반영하여 짓는다.
켄트벡이 자주 사용하는 변수명
 - result: 함수에서 반환되는 결과 객체를 저장한다.
 - each: 컬렉션 원소들을 순서대로 접근할 때, 각 원소를 저장한다.(이름 정보 추가를 원하면 eachX, eachY)
 - count: 횟수를 저장한다.(이름정보를 추가를 원하면 rowCount, columnCount...)
- 선언형 타입: 변수에 대한 일반적 타입을 선언한다.
일반적인 선언 타입(상위 클래스/인터페이스)을 사용하면 유연성이 확장된다.
```java
List members = new ArrayList();
List members = new Vector();
Collection members = new ArrayList();
Collection members = new HashSet();
```
- 초기화: 변수 초기화는 가급적 선언적으로 한다.
변수의 상태는 프로그램 작성 이전에 가정을 할 때 도움이 되는 정보를 준다.
초기화는 변수가 사용되기 전에 알고 있는 상태로 만드는 작업
- 열성적 초기화: 인스턴스가 생성될 때 필드를 초기화한다.
필드에서 초기화를 한다.
필드에서 초기화할 수 없다면 생성자에서 초기화 해라.
- 게으른 초기화 초기화 비용이 높은 객체의 경우, 객체가 실제 사용되기 직전에 초기화한다.
```java
Library.Collection<Person> getMembers() {
	if(members == null) 
    	members= new ArrayList<Person>();
    return members;
}
```
게으른 초기화는 과거 컴퓨터의 처리 능력이 떨어지던 시절에 많이 사용되던 기법이다. 이클립스 처럼 초기 로딩이 빨라야하는 경우 플러그인은 사용 시점 전까지 미루기 위해 게으른 초기화를 사용한다.
게으른 초기화는 열성적 초기화보다 코드를 읽기 어려워진다.
만약, 게으른 초기화를 사용했다면 "이 부분에는 성능이 중요하다"라고 이야기하는 것이다.

### 07 행위
존 폰 노이만(John Von Neumann)은 컴퓨터에 있어 중요한 개념을 처음 도입했다.
컴퓨터는 명령어의 흐름 속의 명령어를 순서대로 하나씩 수행한다는 것이다.
-> 이는 자바를 포함한 많은 프로그래밍 언어에 지대한 영향을 미쳤다.

- 제어 흐름: 연산을 여러 단계로 나타낸다.
자바의 제어 흐름은 언어의 근간중 하나이다.
인접한 구문은 순서대로 수행
조건문을 사용해 특정 상태에서만 코드를 수행
루프를 사용하여 반복적으로 코드를 수행
예외를 사용하여 제어 흐름을 스택 아래쪽으로 한번에 변경.
- 주요 흐름: 주요 제어 흐름을 명확하게 표현한다.
- 메시지: 메시지를 보내서 제어 흐름을 표현한다.
[메시지 3요소](http://leews.8m.com/javascript/JAVA-4.htm)
 - 메시지를 받을 객체의 주소.
 - 처리할 메소드 이름.
 - 메소드에서 필요로하는 어떤 여분의 파라미터.
- 선택 메시지: 여러 선택 사항을 나타내기 위해 메시지 구현자를 다양화한다.
```java
public void displayShape(Shape subject, Bush brush){
	brush.display(subject);
}
````
dispaly() 메시지는 런타임에 브러시의 타입에 따라 구현을 선택한다.
선택 메시지를 사용하면 명시적 조건문의 사용을 크게 줄일 수 있으며 추후 확장이 쉽다.
여러 클래스를 봐야하기 때문에 과도한 선택 메시지 사용은 커뮤니케이션 측면에서 떨어질수 있다.
- 더블 디스패치: 두 가지 축으로 메시지 구현자를 다양화해서 중첩된 선택을 표현한다.
선택메시지를 2depth
```java
//
displayShape(Shape subject, Brush brush){
	subject.displayWith(brush);           // dispatch 1
}
//Rectangle
displayWith(Brush brush){
	brush.displayRectangle(this);
}
//PostscriptBrush
displayRectangle(Rectangle subject) {
	 System.out.println(subject.left() + " " + rect);
}
```
- 분리(순차) 메시지: 복잡한 연산은 밀접한 단위의 연산으로 나눈다.
- 되돌림 메시지: 메시지를 같은 수신자에게 보내서 제어 흐름에 대칭성을 부여한다.
대칭성을 사용하면 코드의 가독성을 높일 수 있다.
```java
//before
void compute() {
	input();
    helper.process(this);
    output();
}
//after
void process(Helper helper) {
	helper.process(this);
}
void compute() {
	input();
    process(helper);
    output();
}
```
되돌림 메시지를 과도하게 사용하는 경우 호출하는 객체에 옮기는 것이 나을 수도 있다.
- 초청 메시지: 다른 방식으로 구현될 수 있는 메시지를 보내서 미래에 일어날 변형을 대비한다.
하위 클래스의 어떤 연산을 변형시킬 것이라 예상되면, 적당한 이름의 메시지를 통해 변경의 여지를 알려주는 것이 좋다.
로직에 대한 기본 구현이 있다면 그 구현을 메시지의 구현으로 삼고, 그렇지 않다면 추상 메소드로 선언해서 초청 메시지임을 분명히 한다.
- 설명 메시지: 로직을 설명하기 위해 메시지를 보낸다.
```java
highlight(Rectangle area) {
	reverse(area);
}
````
위의 예처럼 바로 reverse를 바로 호출하지 않고 highlight를 호출한 이유는 highlight 메소드는 프로그래머의 의도를 전달하기 위한 메소드.
- 예외 흐름: 주요 흐름에 대한 표현을 방해하지 않으면서, 가급적 명확하게 예외적 제어 흐름을 표현한다.
예외 흐름은 주요 흐름의 명료성을 훼손하지 않는 범위 내에서 명료하게 나태나라.
예외 흐름은 조건절이나 예외를 사용해서 표현할 수 있다.
- 보호 구문(보호절): 지역적 예외 흐름은 이른 반환을 통해 표현한다.
보호절의 형태
 - 조건절 + return 사용
 - 반복문 + continue 사용
  
 (과거 프로그래밍에서 각 루틴은 단일 시작 지점과 단일 종료 지점만 갖고 있어야한다는 계명이 있었지만, 자바 같이 짧은 메소드에 대부분 지역 데이터만을 사용하는 경우에 이 지침은 너무 보수적이다.)
- 예외: 비지역적 예외 흐름은 예외로 표현한다.
예외는 여러 함수 호출을 걸쳐서 제어 흐름을 바꾸는 경우를 표현할 때 유용하게 사용된다.
스택상에서 한참 위쪽에 문제가 발생했다면, 이 문제는 스택의 한참 아래쪽에서 해결하는 것이 합리적이다.(켄트벡은 체크 예외를 그닥 좋아하지 않는듯하다.)
예외에는 비용이 들어가고 제어 흐름을 따라가기 힘드므로, 가능하면 순차적 구문, 메시지, 루프, 제어문을 사용해서 제어 흐름을 표현하라. 그렇게 하는 것이 주요 흐름의 이해를 방해하는 경우에만 예외를 사용하라.
- 체크 예외: 명시적 선언으로 예외를 처리한다.
갑작스레 프로그램이 종료되는 것을 막아주기 위해 체크 예외를 사용한다.
하지만 커뮤니케이션이 어려워지고, 코드 수정에 어려움이 증가된다.
- 예외 전달: 예외를 전달할 때에는 예외 처리자에게 적합한 정보를 전달 할 수 있도록 필요에 따라 예외의 형태를 변화한다.

### 08 메소드
메소드 이름을 통해실제 세부 구현과 상관 없이 로직의 목적이 무엇인지 알 수 있다.
메소드를 사용하면 재사용 문제를 해결 할 수 있다. 단순히 호출만하면 끝!!
방대한 로직을 메소드로 나누는 것은 시간, 에너지, 창조력이 필요하다. 지금 당장 잘 나눴다고하더라도, 이후에는 기존 방식이 더 이상 좋은 방식이 아닐 수도 있다. 이는 곧 경험이 필요하다.
메소드를 나누데 필요한 요소로는 메소드의 크기, 목적, 이름등이 있다.
- 조합 메소드(composed method): 다른 메소드에 대한 호출로 메소드를 작성한다.
추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성하라.
```java
void compute() {
	input();
    flags|= 0x0080;
    output();
}
```
위의 코드는 코드의 자연스런 흐름을 깨고, 독자는 갑자기 추상화 수준이 바뀌면 흐름이 깨진다.
짧은 메소드의 반론의 요지는 성능이다. 하지만 (켄트벡이) 측정결과 비용은 20~30% 정도이다. 이 수치는 프로그램에서 용인할만한 수준이라고 한다.(응??? 그런가???)
메소드의 길이는 5~15줄이 넘어가면 안된다 - 메소드 이름에서 암시하는 작업을 하려면? 코드 세부사항을 이해하려고할 때 세부 사항이 길면 이해가 어려워진다.
이해하기 어려울 정도로 많은 세부사항이 있는 경우, 메소드를 나누기 쉽지 않을 때는 세부 구현을 정리해서 담을 수 있는 메소드 객체를 생성해서 문제를 해결한다.
메소드 크기를 결정하는 다른 요소는 특화다. 적당한 크기로 메소드를 작서알 경우, 코드를 하위 클래스로 복사하거나 여러 개의 메소드를 오버라이드하거나 하지 않고 손쉽게 오버라이드가 가능하다.
일단 동작하는 코드를 만들고 구성 방식을 결정하다. 코드 구성에 미리 시간을 들이게 되면, 구현 도중 새로 알게 되는 사실 때문에 했던 일들을 번복하는 경우가 많다.
메소드를 잘 나눴다고 생각했지만 코드가 읽기 어려운 경우는 메소드들을 인라인시켜서 커다란 메소드를 만든 후, 메소드 구현에서 새로 얻은 경험을 바탕으로 다시 메소드를 나누는 방법 사용.
- 의도 제시형 이름: 메소드가 의도하는 바를 나태내는 이름을 사용한다.
구현정보등 다양한 정보를 전달하고 싶을 것이나 메소드의 이름을 통해서는 의도만 전달하고, 그 외 정보는 다른 방식으로 전달하는 것이 좋다.(어떻게???)
- 메소드 가시성: 메소드는 가급적 전용으로 한다.
public, default, protected, private의 메소드 가시성 역시 프로그래머의 의도를 전달한다.
가시성 선택시 고려해야할 비용
 - 미리의 유연성: 외부에 드러나는 인터페이스가 많은 경우 수정하는 것이 어렵다.
 - 객체를 사용하는데 들어가는 비용: 노출 인터페이스가 적은 경우 사용하는 측에서 필요 이상으로 많은 작업을 해야한다.
가시성 결정 전략
 -공용: 패키지 외부에서도 이 메소드가 유용하다. 이 가시성을 사용하는 프로그래머는 이 코드 관리를 책임지겠다는 의미이기도 하다. 메소드를 수정할 경우 모든 수정을 본인이 담당하거나, 최소한 사용자들에게 수정 사항을 알려줄 책임이 있다.
 - 패키지: 같은 패키지의 다른 객체에는 유용하지만 패키지 외부의 객체에는 공개하지 않겠음을 의미.
먼저 가장 제한적인 가시성을 선택할 후, 필요에 따라 조금씩 가시성을 높여라.
메소드를 final로 선언하는 것은 메소드를 변경하는 것이 복잡하고 미묘한 결과를 유발한다는 것을 의미시킴 하지만 오버라이드하면 더 쉽게 될 것이 더 복잡하게 처리 되는 경우가 있어 켄트벡은 사용하지 않는다고 한다.용용하는 것이 보통이며, 코드가 복잡할수록 효과가 크다.
- 메소드 객체: 복잡한 메소드는 새로운 객체로 바꾼다.
메소드 객체 패턴은 복잡하게 꼬여있는 메소드를 읽기 쉽고 명확하면서도 세부 구현 전달이 쉽도록 바꿔준다. 이 패턴은 동작하는 코드가 나온 후에 사용
[참고](http://refactoring.com/catalog/replaceMethodWithMethodObject.html)
 메소드 객체를 생성하는 순서
 1. 메소드의 이름을 따서 이름을 정한다.(ex: complexCalculation()->ComplectCalculator)
 2. 메소드에서 사용하는 각 파라미터, 지역 변수, 필드에 대해 새로운 객체상의 필드를 생성한다. 일단 기존에 사용한 이름과 같은 이름을 사용한다.(이름은 나중에 변경 가능)
 3. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다.
 4. 본래 메소드를 새로운 클래서의 calculate()라는 메소드로 복사한다. 기존 메소드에서 파라미터, 지역 변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 되었다.
 5. 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다. 예를 들면 다음과 같다.

    ```java
		complexCalculation() {
        	new ComplexCalculator().calculate();
        }
    ```
 6. 본래 메소드에서 필드를 설정하는 부분이 있었다면, 다음과 같이 calculate()가 반환된 후에 설정해준다.

	```java
    	complexCalculation() {
        	ComplexCalculator calculator= new ComplexCalculator();
            calculator.calculate();
            mean= calculator.mean;
            variance= calculator.variance;
        }
    ```
- 오바리이드 메소드: 특화를 나타내기 위해 오버라이드를 사용한다.
상위 클래스의 다른 메소드를 super.method() 호출하는 경우 혼란을 치를수 있으니 가급적 상위클래스의 메소드는 같은 이름의 메서드로 한정한다.
- 오버로드 메소드: 같은 연산에 대해 다른 인터페이스를 제공한다.
- [helper method](http://forums.devshed.com/java-help-9/helper-method-350163.html)
"이 메소드를 사용할 수 있는 다양한 포맷이 존재한다."
메소드 오버로드는 파라미터 타입만 다를 뿐, 같은 연산을 수행해야한다.
- 메소드 반환 타입: 반환 타입에는 가급적 가장 일반적인 타입을 사용한다.
- 메소드 주석: 코드 자체에서 쉽게 얻을 수 없는 정보는 주석을 통해 나타낸다.
- 도우미 메소드: 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용한다.
[helper method](http://forums.devshed.com/java-help-9/helper-method-350163.html)
당장 관련된 세부 구현을 숨기고 메소드 이름을 통해 프로그래머의 의도를 나타냄으로써, 복잡하고 거대한 연산 코드를 좀더 읽기 좋게 하기 위해 사용.
도우미 메서드는 보통 private로 선언, 상속해서 하위 클래스가 사용할 경우만 protected
- 디버그 출력 메소드: toString()을 사용해서 유용한 디버그 과련 정보를 출력한다.
- 변환: 객체 형변환은 명확하게 표현한다.
변환의 빈도가 높은지, 클래스간의 의존성 증가되는지 확인후 변환 패턴을 사용.
● 구현방법
 - 기존 정보를 복사해서 새로운 타입의 실제 객체 생성
 - 두 객체간의 공통 인터페이스를 찾아서 인터페이스를 통해 코드를 작성
- 변환 메소드: 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공한다.
유사한 타입의 객체 간 변환을 표현하려 하고 필요한 변환의 수에 제한이 있다면, 기존 객체에 메소드를 추가해서 변환을 나태낼 수 있다.
	```java
    class Polar {
    	Cartesian asCartesian(){
        	...
        }
    }
    ```
대개의 경우 변환 메소드보다 변환 생성자를 선호(클라이언트 코드에서 원본 객체를 다룰 수 있게 처리)
- 변환 생성자: 대부분의 변환에 대해서는 원본 객체를 인자로 취하는 변환될 객체의 생성자를 제공한다.
String에 변환 메서드를 넣는다면 asFile, asUrl...... String 클래스는 너덜너덜해질 것이다.
File(String name), Url(String spec)처럼 클라이언트에서 생성자를 통해 객체 생성.
- 생성: 객체 생성을 명확히 표현한다.
- 완결 생성자: 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다.
생성 조건이 많다면 여러개의 생성자를 작성하고, 모든 생성자는 하나의 생성자를 사용해서 초기화한다.
- 공장 메소드: 좀더 복잡한 객체를 생성할 때, 생성자 대신 정적 메소드를 사용한다.
ex: Rectangle.create(0, 0, 50, 200);
객체 생성외에 다른 의도가 있는 경우만 사용.
장점: 추상타입 반환 가능(hm... 결국엔 구현체일텐데...), 의도가 담긴 별도의 이름을 가질 수 있음.
단점: 복잡성이 증가.
- 내부 공장: 좀더 많은 설명이 필요하거나 이후 개선이 필요한 객체 생성의 경우 도우미 메소드로 캡슐화한다.
객체 생성시 생성 과정이 너무 복잡한 경우 새로운 객체를 생성하고 반환하는 메소드를 만든다.
보통 lazy initialize때 사용

	```java
    getX(){
    	if(x==null)
        	x= computeX(); <=요놈
        return x;
    }
```
- 컬렉션 접근자 메소드: 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공한다.(수정에 대해서는 차단)

컬렉션 프로토콜을 중복해서 구현하고 있다면, 설계상의 문제가 있을 확률이 높다. 객체에서 클라이언트가 필요로하는 적합한 작업을 제공한다면, 내부 데이터 접근을 많이 허용해야 할 필요 가 없다.
	```java
    List<Book> getBooks() {
    	return books;
    }
```
위와 같이 컬렉션을 직접 전달하면 사용자가 컬렉션을 조작할 수 있으므로 혼선 초래 할 수 있다.
```java
    List<Book> getBooks() {
    	return Collections.unmodifiableLsit(books);
    }
```
위와 같이 수정 불가능한 컬렉션으로 바꿀 수 있지만, 클라이언트측 디버깅에 어려움이 생긴다.
컬렉션 조작은 의미있는 한도에서 최소한으로만 제공한다.
```java
    void addBook(Book arrival) {
    	books.add(arrival);
    }
    int bookcount() {
    	return books.size();
    }
```
Iterator를 제공할 수 있지만 remove가 위험하다.
    ```java
    Iterator<Book> getBooks() {
    	final Iterator<Book> reader= books.iterator();
        return new Iterator<Book>() {
        	public boolean hasNext() {
            	return reader.hasNext();
            }
            
            public Book next() {
            	return reader.next();
            }
            
            public void remove() {
            	throw new UnsupportedOperationException(); //runtime exception이기 때문에 위험하고 디버깅이 어렵다.
            }
        }
    }
```
- 불린 설정 메소드: 커뮤니케이션에 도움이 된다면, 불린 값을 설정하는 두 개의 메소드(상태별로 하나씩)를 제공한다.
	```java
    void valid() {...}
    void invalid(){...}
    //state를 넣어야하는 경우는 아래와 같이 처리
    void setValid(boolean newState) {
    	if(boolean expression) 
        	cache.valid();
        else
			cache.invalid();
    }
```
- 쿼리(질의) 메소드: isXXX라는 이름으로 된 메소드를 사용해서 불린 값을 반환한다.
때론 객체는 다른 객체의 상태에 따라 결정을 내려야 한다. (보통 객체는 스스로 결정을 내리게 되므로 이는 이상적인 상황이 아니다.) 하지만 객체가 프로토콜을 통해 다른 객체의 결정을 동와야 할 경우에는 'be'동사나 'have'동사를 사용하라.
-> 보통 의존적인 로직이 많다면 이는 로직에 문제가 있다고 볼 수도 있다. 의존적인 내용이 많다면 의족을 하고 있는 객체에 해당 로직을 옮겨라.
- 동등성 메소드: equals()와 hashCode()를 함께 정의한다.
동등성 비교는 equals(Object other)와 같이 다른 클래스와 quals를 할 수 있다. 이에 대비해서 잘못된 타입인경우 ClassCastException, 또는 IllegalArgumentException을 던져야한다.
serialNumber와 같은 유니크한 값을 가져야하는 객체인경우는 hashCode에 사용될 수 있다.
동일성에 대한 심플한 해법은 imumtable한 객체가 동등하다면 언제나 동등하다는 정책을 취한다.
	```java
    static Instrument create(String serialNumber) {
    	if (cache.containsKey(serialNumber)) 
        	return cache.get(serialNumber);
        Instrument result= new Instrument(serialNumber);
        return result;
    }
```
- 취득 메소드: 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공한다.(getter)
- 설정 메소드: 드물게, 메소드를 사용해서 필드 값을 설정한다.(드문가? -_-?) (setter인것 같은데 좀더 여러가지 의미로)
설정 메소드는 의존성 문제가 발생되기 때문에 가급정 외부에서 사용을 피해야한다.
메소드 목적에 따라 인터페이스 이름을 정하면 코드 읽기가 쉬워진다.
paragraph.setJustification(Paragraph.CENTERED);
-> paragraph.centered();

특정 객체 전용인 경우는 주석이라도 표시해서 독자를 배려하자. 의도를 잘 드러낼 수 있는 체계적인 인터페이스를 제공하는 것이 좋다.
- 안전한 복사: 접근자 메소드를 통해 전달하거나 전달되는 인스턴스를 복사해서 앨리어스(alias) 문제를 회피한다.
취득 메소드나 설정 메소드를 사용하면 앨리어스 문제가 발생할 수 있다.(2개의 객체가 다른 객체에 대해 배타적인 접근권이 있다고 가정하는 것)
앨리어스 문제는 더 심각한 설계상의 문제(예를 들어 어떤 객체가 어떤 데이터에 대한 책임이 있는지 명확치 않은 문제)가 있다는 신호지만, 어떤 경우에는 객체를 반환하거나 저장하기전에 복사본을 만드는 방식으로 이런 문제를 피할 수 있다.

    ```java
	List<Book> getBooks() {
    	list<Book> result= new ArrayList<Book>();
        result.addAll(books);
        return result;
    }ㅌㅊㅍㅋㅌㅊㅋㅌㅍㅋㅌㅍ
    void setBooks(List<Book> newBooks) {
    	books= new ArrayList<Book>();
        books.addAll(newBooks);
    }
    ```
위를 안전한 복사라고 부른다. 하지만 성능저하가 따른다. 이는 외부 접근에서 코드를 보호하는 일시적인 해결책일 뿐다ㅏ. 가급적 어떤 구현의 핵심 기법으로 사용하는 것은 피하는 것이 낫다. immutable object와 composed method를 통해 더욱 간결하고 커뮤니케이션에 도움이 되면서 문제를 적게 발생시키는 인터페이스를 만들 수 있다.

### 09 컬렉션
컬렉션은 여러종류의 메타포가 녹아져있다. 컬렉션은 인터ㅍㅍ페이스는 여러 객체의 묶음에 대해 제각각 다른 의미를 전달, 컬렉션 구현은 주로 성능에 관련된 프로그래머의 의도를 전달. 따라서 사용과 커뮤니케이션을 위한 코드 작성 사이에는 관련이 있다.

##### 메타포
1. 여러 값을 가진 변수(multi-valued variable): 컬렉션이 가리키는 객체가 어떤 것이냐 하는 것이 중요. 여느 변수와 마찬가지로 컬렉션 변수에도 값을 할당, 조회, 변수 메세지를 보낼 수(for문 사용) 있다. 자바의 경우는 컬렉션을 별도의 객체로 취급하므로 여러값을 가진 변수라는 정체성이 희미해짐. 
2. 컬렉션이 객체: 컬렉션에 대해 값을 얻는 것이 가능, 인자로 전달, 동등성 테스트, 메시지를 보낼 수 있다. 여러 객체가 컬렉션을 공유 가능(앨리어스 문제 발생 가능. 여러 관련있는 인터페이스와 구현의 집합이기 때문에, 확장된 인터페이스와 새로운 구현을 통해 확장이 가능. 컬렉션은 객체이기 때문에 인자로 전달이 가능하므로 call by reference 효과를 얻을 수 있다. 호출된 함수에서 전달된 변수 값을 변경하면 그 효과는 호출 루틴에서도 나타난다. 참조호출은 예상치 못한 결과를 가져올 수 있기 때문에 디버깅이 몹시 어려워진다. 그래서 컬렉션 사용에는 규범이 있다.
3. 수학적 집합: 크기(size()), 소속성(contains())등 이있다. 하지만 부분적으로 적용 합집합, 교집합, 차집합, 여집합...등등이 적용되어 있지 않음.

##### 이슈
컬렉션은 가장 일반적인 타입을 쓰라는 규칙을 적용하면 더 헤갈린다(Iterable, Collection, List...) 모두 List로 쓰는게 훨씬 깔끔.
컬렉션의 표현
1. 크기: 
2. 원소간의 순서: 컬렉션에 추가된 순서 또는 알바벳 순서와 같은 외부에서 정의한 순서.
3. 독자성: 유니크 or 중복
4. 접근: 순차 or 키
5. 성능은 프로그래머의 의도를 전달: 선형탐색(Collection) or 인덱싱(Set | Map)

##### 인터페이스
- 배열(Arrays아닌 자바 문법적으로 제공하는 배열): 가장 단순하지만 가장 유연하지 못한 컬렉션. 크기 고정, 원소 접근 방법 용이, 빠름
자바에서는 인터페이스 대신 문법적으로 제공. 저자가 테스트시 ArrayList에 비해 접근 속도 10배 이상 빠랐다고함. 유연성 때문에 다른 컬렉션을 쓰는게 낫지만 성능이 이슈라면 사용 고려 가능
- Iterable: 기본적인 컬렉션 인터페이스로 순차 열람(iteration)을 지원. 다른 기능 없다. 
어떤 변수를 Iterable로 선언하는 것은 그 변수가 여러 개의 값을 갖고 있음을 뜻함. java 5의  루프에 근간이 됨. Iterable을 사용하면 원소가 지워지는 것을 막을 수 없는 것에 주의
- Collection: 원소 추가, 제거 및 소속 테스트를 지원
Iterable을 상속, 원소 추가, 삭제, 검색, 크기 측정등의 메소드를 추가로 지원. 구현클래스는 알고리즘/자료구조에 따라 특성이 있음. 컬렉션은 수학의 집합과 유사 합집합, 교집합, 차집합 같은 연산(addAll(), retainAll, removeAll())을 지원(새로운 컬렉션을 리턴)
- List: 원소의 순서가 정의되어 있으며, 컬렉션상의 위치를 통해 원소에 접근할 수 있다.(키는 정수)
Collection을 기반으로 해서 원소간에 정해진 순서를 부여한 것. 컬렉션상의 인덱스(원소간의 순서)를 통해 원소를 접근 가능. 
FIFO
- Set: 중복된 원소가 없는 컬렉션
Set은 원소 사이에 순서가 없다. 순차 열람후 다시 순차 열람시 이전과 같은 순차 열람을 보장하지 않는다.
- SortedSet: 중복 원소가 없으며 원소 간의 순서가 정해진 컬렉션
Comparator에 의해 순서 정함. 명시적으로 순서가 없는 경우 natural order가 사용
- Map: 키에 의해 원소를 저장하고 접근하는 컬렉션(키는 객체)
키는 중복 불허, 데이터는 중복 허용. 원소 데이터의 순서는 보장 안함
Map은 내부적으로 키, 데이터에 대한 2개의 컬렉션을 유지.

##### 구현
가장 많이 ArrayList와 HashSet
###### Collection
기본 구현은 ArrayList 만약, 컬렉션의 크기에 비례해서 연산이 커지는 contains와 이 메소드를 사용하는 다른 메소드(ex: remove())들이 성능을 제약한다면 HashSet으로 바꾸는 것도 고려
###### List
기본 구현체 ArrayList, LinkedList
ArrayList: 원소 접근 빠름, 원소 추가, 제거 느림
LinkedList: 원소 접근 느림, 원소 추가, 제거 빠름
###### Set
기본 구현체HashSet, LinkedHashSet, TreeSet(사실상 SortedSet의 구현체)
HashSet: 가장 빠름, 원소간 순서 보장 안함
LinkedHashSet: 순서 보장, 추가시 30%정도 시간 더 걸림
TreeSet: 원소 추가, 삭제 시간이 log n에 비례해서 커짐
###### Map
Set 구현과 비슷한 패턴을 보임
HashMap, LinkedHashMap, TreeMap

##### Collections
###### 검색
indexOf() 연산에 걸리는 시간은 리스트의 크기에 비례.
**만약 원소들이 정렬되어 있다면** binary search를 사용해서 log2n에 비례하는 시간에 검색 가능. [Collections.binarySearch(list, element)](http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#binarySearch(java.util.List,%20T)
이진 검색은 ArrayList와 같이 상수 시간에 임의의 접근이 가능한 리스트에 대해서만 향상된 성능을 제공한다.
``` java
     for (int i=0, n=list.size(); i < n; i++)
         list.get(i);         //상수시간에 접근이 가능하기 때문에 next()보다 빠름. why???? java api  java.util.RandomAccess interface 참조함
//runs faster than this loop:

     for (Iterator i=list.iterator(); i.hasNext(); )
         i.next();
```

###### 정렬
Collections는 리스트 원소간의 순서를 바꾸는 연산을 제공(reverse(list), shuffle(list), sort(list),...)
이진 검색과 달리 ArrayList와 LinkedList간의 정렬 성능은 거의 같다. 컬렉션의 원소들이 일단 배열로 복사되어 정렬된 후 다리 본래 컬렉션으로 복사되기 때문.
###### 수정 불가능한 컬렉션
Collections.unmodifiableCollection(Collection collection);
###### 단일 원소 컬렉션
하나의 원소만 담은 Set, List, Map을 쓰고 싶다면 Collections.singleton(...)을 사용. 수정 불가
###### 무원소 컬렉션
수정 불가한 empty 컬렉션
Collections.emptyList()
##### 컬렉션 확장
상속을 하는 경우 컬렉션에서 제공하는 많은 연산들이 클라이언트측에 부적절할 수 있다ㅏ. 수행하지 않아야 할 연산들은 UnsupoortedOperationException을 발생시켜야하고 재사용하기 위해 쓸모없는 코드를 대량 발생 시킬 수 있다. 컬렉션을 상속하느라 나중에 이용할수 있는 상속을 어렵게 만들수 있다.
차라리 위임을 사용하는 편이 낫다.

```java
class Library {
	Collection<Book> books = new new ArrayList<Book>();
    ....
    Book getBookByISBN(ISBN);
    Book getBookByID(UniqueID);
}
```
위임을 사용할 경우 유용한 메서드에 한해 의미 있는 이름을 붙여서 재상용하면 편리하다.(상속한다고 못하는건 아니지만 -_-ㅋ)

### 10 발전하는 프레임워크
##### 애플리케이션 수정 없이 프레임워크 수정하기
가능하면 private: 켄트벡은 어플리케이션 개발할 때 대부분의 코드를 default로 하지만 프레임워크는 private으로 가능하면 만든다. 클라이언트 애플리케이션에 영향을 끼치지 않고 프레임워크의 데이터 형식을 마음대로 고칠 수 있다.(걍 다 가능하면 private로는... 흠...)

##### 호환성 없는 업그레이드
병렬 아키텍처(parallel architecture): 삭제될 API를 일정 기간 동안 deprecation하는 것. 이는 복잡도를 높이지만 업그레이드로 인한 문제점을 줄여준다.
패키를 사용하여 클라이언트 코드를 업그레이드: 기존 클래스 이름 그대로 하면서 패키지만 변경, 클라이언트 코드에서는 import문만 변경하면 되기 때문에 위험도가 낮다.

##### 호환성을 유지하는 업그레이드
이상적인 프레임워크는 변하지 않는 부분만 클라이언트가 사용하는 것이지만 이는 불가능에 가깝기 때문에 변경에 전략을 세워야한다.
1.후방 호환성 업그레이드를 통해 프레임워크에 구형 메소드 호출과 구형 객체 전달을 지원
2.전방 호환성 업그레이드를 통해 신형 스타일의 객체를 클라이언트에 전달해도 동작하도록 지원
둘다 지원시 cost 증가 고려해야함.

##### 라이브러리 클래스
라이브러리 클래스를 사용하면 복잡도를 높이지 않으면서도 미래에 대비할 수 있다.
Collections 클래스는 클래스를 통한 API를 제공한 좋은 예이다.
단점은 표현할 수 있는 개념과 변형의 수가 제한적.
##### 객체
프레임워크를 객체로 나타낼 때에는 네가지 이슈가 있다ㅏ.
- 사용 스타일: 클라이언트가 프레임워크 객체를 인스턴스화하여 사용할 것인가 아니면 확장(상속)해서 사용할 것인가?
프레임워크는 인스턴스화(instantiation), 설정(configuration), 구현(implementation)의 세 가지 주요 스타일을 지원한다. 각 스타일은 사용의 편의성, 유연성, 안정성 면에서 서로 다른 모습을 보인다.
 - instantiation: 가장 단순한 스타일  new Socket(...), 사용자가 로직의 변형을 필요로 하지 않고 데이터의 변형만을 필요로하는 경우 사용
 - configuration: 인스턴스화보다 복잡하지만 유연.  ( @FunctionalInterface를 생각하면 쉬운듯 )
 ```java
 Comparator<Author> byFirstName= new Comparator<Author>() {
 	public int compare(Author book1, Author book2) {
    	return book1.getFirstName().compareTo(book2.getFirstName());
    }
 };
 SortedSet<Author> sorted= new TreeSet<Author>(byFirstName);
```
 설정은 데이터뿐만 아니라 로직의 변형도 지원하므로 인스턴스화보다 유연하다. 하지만 계속해서 같은 인터페이스를 사용해야하므로 프레임워크를 발전시키는 데 제한이 생기고 클라언트 코드에 대한 호환성을 보장해주기 어려워진다. 또한 실질적으로 표현할 수 있는 변형의 종류에도 제한이 있다.
 - implementation: 클라이언트가 설정에서 제공하는 것 이상으로 많은 종류의 로직의 변형을 필요로 하는 경우 사용. 이 경우 클라이언트는 프레임워크에서 사용할 클래스를 생성해서 프레임워크에 전달한다. 
구현은 3가지 스타일중 미래에 있을 설계 변경을 가장 크게 제약한다.

    Junit 참조
    - JUnitCore는 run(Class...) 정적 메소드를 사용해서 모든 클래스의 모든 테스트를 수행한다.
    - JUnitCore는 인스턴스화를 지원한다. 각 인스턴스에 대해서는 테스트 수행과 결과 통보에 관한 세부 지시를 할 수 있다.
    - @Test, @Before, @After와 같은 표기를 통해 어떤 코드가 언제 수행되어야 하는지 설정할 수 있다.
    - @RunWith는 일종의 구현이다. 표준적인 테스트 수행이 적합치 않은 경우 테스트 작성자는 자신만의 수행 절차를 구현할 수 있다.

- 추상화: 클래스 수준의 세부 사항을 인터페이스로 나타낼 것인가 클래스로 나타낼 것인가? 상대적으로 안정적인 세부 사항에 대해 어떤 가시성을 사용할 것인가?
구현 스타일을 사용시 추상화된 개념을 인터페이스 또는 상위클래스로 어느 것으로 전달할지 결정해야한다.
 - 인터페이스
 클라이언트의 최소 구현 로직을 구현하게 함. 단 인터페이스 변경시 클라이언트 코드를 수정해야하기 때문에 변경에 어려움이 따름.
 이점은 세부 사항을 가급적 적게 드러낸다는 것. 연관된 인터페이스를 하나의 클래스에서 구현하면 커뮤니케이션 증가
 단점은 인터페이스 변경. 연관되지 않은 인터페이스를 하나의 클래스에서 구현하면 커뮤니케이션 저하
 
 버전 인터페이스: 새로운 기능을 하위 인터페이스를 만들어 새로운 연산을 추가하여 기존 클라이언트 코드의 변경을 안해도 되게하는 전략
 이러한 유연성에는 복잡도의 증가가 따름
 ```java
 	if (layout instanceof LayoutManager2) {
    	layoutlmanager2 layout2 = (LayoutManager2) layout;
        layout2.newOperation();
    }
```
 - 상위클래스
 클래스는 인터페이스보다 세부 사항을 나타낼수 있으면서, 상위클래스에 새로운 메소드를 추가해도 호환성에 문제가 발생하지 않는다. 
가급적 클래스에서 노출하는 세부 사항을 줄여서 인터페이스에서 노출하는 정보 수준에 가깝게 하라. 
 abstract: 클라이언트에게 로직을 전달할때 유용. 인터페이스와 동일하게 새로운 abstract 메소드가 생기면 클라이언트 코드에 변경이 필요
 final: 오버라이드를 금지 시키는게 프레임워크 개발자에게는 유익할지 모르나 클라이언트에게 제약을 걸어서 유용한 경우는 어렵게 만드는 경우가 많다고함. 가능하면 클라이언트에게 문제를 일으키지 않는 경우만 사용
 
 "프레임워크 내에는 보이지만 클라이언트에는 보이지 않는" 가시성수준이 필요하지만 자바의 패키지 가시성으로는 어렵다. 이럴땐 패키지명으로 의미를 전달한다. ex: "org.eclipse.jdt" /  "org.eclipse.jdt.**internal**"
 
- 생성: 어떻게 객체를 생성하는가?
 - 클라이언트 생성금지(no creation): 클라이언트가 프레임워크 객체를 직접 생성하는 것을 금지. 복잡도를 낮출수는 있다.
 - 생성자(constructor): 클라이언트 입장에서는 단순 명확. 클라이언트가 사용하기 쉬운 생성 인터페이스를 원하고, 프레임워크에서 클래스의 패키지, 이름, 구상, 클래스를 바꾸지 않아도 괜찬은 경우라면 사용하는 것이 합리적(대부분의 자바 라이브러리가 취하는 방법)
 - 공장 메소드(factory method): ----------------잉??? 왜 내용이....빠졌지? 정적 공장과 연결된듯....
 - 정적 공장(static factories):  클라이언트가 객체를 생성하는 복잡도가 상당히 증가하지만, 프레임워크 개발자는 미래의 설계 수정에 유연성을 갖게 된다. factory method 명을 통해 의도를 쉽게 파악할 수 있다.
 ex: ArrayList.create()    <-실제로는 없음.
 - 공장 객체(factory object): factory object를 사용하면 static factories를 사용하는 것보다 높은 유연성을 얻을 수 있지만 코드를 읽기 어려워진다. 
공장 객체를 전역적으로 사용한다면 정적 공장 메소드보다 나을 것이 없다. 공장 객체는 지역적으로 사용해야 좀더 효과적이다.
 ex: Collections.factory().createArrayList() <- pseudocode
- 메소드: 메소드를 어떻게 구성하면 클라이언트에게는 유용성을, 프레임워크 개발자에게는 유연성을 제공할 수 있을까?
클라이언트는 getter/setter 사용시 내부 자료구조를 직접 사용할수 있게 된다. 클라이언트가 프레임워크의 내부 자료구조에 의존하게 된다면 프레임워크 수정이 매우 어렵게된다.
setVisible(boolean) 보다 visible(), invisible() 메소드를 제공하라 제3의 상태가 필요하면 inactive()처럼 상위클래스에 메소드를 추가하라. 인터페이스인경우는 setVisible(State)를 사용해서 Enum을 사용하라.
프레임워크 내부 자료구조를 제어할 getter/setter가 꼭 필요한 경우는 메소드 이름에 역할을 반영하라.

공개된 메소드에 파라미터를 추가할 경우에는 호환성을 위해 기본값을 제공하라.












