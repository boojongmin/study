켄트벡의 구현패턴 - 읽기 쉬운 코드를 작성하는 77가지 자바 코딩 비법

- 패턴
- 가치와 원칙
- 동기
메소드 <-(로직의 분화)- 행위 <-(유사한 로직)-클래스-(다른데이터)->상태-(여러개의 데이터)->컬렉션
<프레임워크>

클래스: 왜, 어떻게 클래스를 생성해야 햐는지, 클래스에서 어떤 식으로 로직을 표현해야 하는가에 관한 패턴
상태: 상태를 저장하고 읽어오는 데 관한 패턴
행위: 로직, 특히 여러 개의 수행 경로(alternative path)를 표현하는 패턴
메소드: 메소드를 작성하는 데 관한 패턴, 나중에 내 코드를 읽을 사람은 내가 작성한 메소드 이름을 보며 어떤 생각을 할 것인가?
컬렉션: 컬렉션을 선정하고 사용한 데 관한 패턴
발전하는 프레임워크: 애플리케이션이 아닌 프레임워크를 작성할 때는 어떤 식으로 패턴을 변화시켜 사용해야 하는가?

읽기 쉬운 코드란 읽기 쉬운 글을 쓰는 것과 같다.
대상 독자를 저아고 명확한 전체 구조를 갖고, 전체 줄거리를 생각해서 세부 묘사를 해야한다.

프로그래머는 혼자 생각하면서 보내는 시간이 너무 많으므로, 다른 사람의 관점에서 코드를 바라보려 시도하는 것 자체가 커다란 변화이다.
컴퓨터가 이 코드를 어떻게 처리할까 + 내 생각을 다른 사람에게 어떻게 전달할까

언어에서 제공하는 각 요소들이 어떤 문제를 해결하기 위해 설계된 것인지 알아야한다. 구현 패턴은 프로그래밍을 할 때 빈번히 발생하는 문제들과, 그 문제들에 대한 해결책을 자바로 제시한 것

인생이 70년이라고할때 우리 인생은 20억초에 불과하다...

### 01 소개

코드를 통한 커뮤니케이션의 단계
1. 생각을하며 프로그래밍-본능에 의해 코딩하는 것을 멈추고 내가 어떤 생각을 하고 있는지 살펴볼 수 있는여유
2. 다른 사람의 중요성을 인식
3. (2)를 인식후 그 생각을 실천으로 옮기기.


디자인패턴 - 보통 객체 간의 관계 설정, 하루에 몇 차례하는 결정
구현 패턴 - 몇 초에 한번씩 하게 되는 결정, 어떤 경우 어떤 언어의 구성 요소를 사용할지에 대한 것과, 그 결정에 대해 나중에 그 코드를 읽은 다른 이가 어떤 결론을 내릴 것인지에 대해.


### 02 패턴
대부분의 프로그램에는 다음과 같은 법칙이 적용된다.
- 프로그램을 새로 짜는 경우보다는 기존 프로그램을 읽는 경우가 많다.
- 프로그램에 있어 '완성'은 없다. 최초에 프로그램을 개발하는 데 드는 노력보다는 이후 프로그램을 수정하는 데 들어가는 노력이 더 크다.
- 프로그램 구조는 몇 가지 상태와 제어 흐름 개념으로 결정된다.
- 프로그램을 읽는 사람은 개념과 더불어 세부 사항까지도 이해해야 한다. 세부 사항을 이해해야 전체 개념에 대한 그림을 그릴 수 있고, 한편 전체 개념을 이해해야 세부적인 구현 내용을 이해할 수 있기 때문이다.

@패턴을 사용하는 것은 처음에 답답할 수 있다. 하지만 패턴은 시간과 에너지를 줄여준다.(매번 어떻게 할지 고민하는 것 보다, 평상시 습관대로 하는 편이 훨씬 적은 노력이 든다. - 이래서...인간들에게 관성이 생길수도...)
@패턴은 절대적인 진리가 아니므로, 사람의 의사 결정을 돕는 도구 정도로 생각하고 상황에 딸 패턴을 적절히 변화 시켜 사용해야한다.

### 03 프로그래밍 이론
의사 결정 사항에 영향을 미치는 동력
- 가치(value): 모든 프로그래밍에 적용되는 주제. 프로그램을 잘 짜는 사람은 타인과의 커뮤니케이션을 중시하고, 코드의 과도한 복잡성을 피하면서도 유연성 있는 코드를 작성. 커뮤니케이션, 단순성, 유연성의 가치는 모든 프로그래밍을 할 때 내리는 모든 의사 결정에 영향을 미친다.
- 원칙(principle): 가치처럼 언제나 적용되는 것은 아니지만 많은 패턴에서 사용된다. 항상 중요하지만 때로는 직접 적용하기 어려운 가치와, 적용법은 명확하지만 조금은 지엽적인 패턴 사이의 가교 역할을 하는 것이 역할. 패턴들간에 결정이 애매한 상황에서 원칙을 이해한다면 훌륭한 해결책을 찾을 수 있다.

무엇인가를 동의하지 않는다면 어느 수준(layer)에서 차이가 있는지 파악하는 것이 중요하다. 단순 괄호를 가지고 논쟁하는데 그 내면적으로 원칙을 동의하지 않은 상태였는데 논쟁이 끝날 수가 없다.

#### 가치
- 커뮤니케이션
- 단순성
- 유연성

-> 최고의 프로그래머는 확장성을 고려해서 프로그램을 짜지만, 불필요한 요소를 사용하지 않으며, 읽고 이해하기 쉬운 프로그램을 짠다.

##### 커뮤니케이션
코드를 쉽게 이해하고, 수정하고 사용할 수 있다면 그 코드는 개발자와 커뮤니케이션을 하고 있다고 이야기할 수 있다.
컴퓨터 뿐만 아니라 타인을 고려해서 프로그램을 짜면, 애해가 쉽고 깔끔, 더 효율적이 되고 생각은 명확해진다. 새로운 관점에서 코드를 바라보게 된고, 스트레스가 줄어들며, 다른 사람도 볼 만한 코드가 만들어진다.
경제적으로도 효과가 높다. - 유지보수.

@"다른 사람이 이걸 보면 어떤 생각을 할까?"라는 생각을 하면서 코딩!!

##### 단순성
(그래프의 원본에서 불필요한 점을 지운 그래프는 원본에 비해 참신하고 이해하기도 훨씬 쉽다.)

복잡도를 낮추면(단순하게하면) 커뮤니케이션이 쉬워진다(코드를 읽기 쉬워진다). 유지보수시 복잡성이 높아지면 손을 대기 어려워진다. 프로그래밍을 하면서 불필요한 코드를 제거해 나가야한다.

프로그램을 최대한 단순화
의미없는 코드는 모두 제거
설계시 과도한 요소 모두 제거
요구사항을 분석해서 꼭 필요한 사항만 뽑아내기 등.

단순성은 커뮤니케이션의 증가를 부른다 하지만 과도한 단순화가 커뮤니케이션을 저해할 수 있다. 이때는 커뮤니케이션에 더 신경을 써서 프로그래밍을 한다.

##### 유연성
비효율정인 코딩이나 설계를 정당화해주는 가치
(프로그램 수정이 유연해야한다.)
ex) 상수값을 직접 코딩하는게 아니고, 프로퍼티 파일을 만들어서 파일을 읽고 파싱해서 상수를 할당. -> 복잡성이 증가된다. 하지만 이 프로그램은 유연하다. 유연성을 통해 프로그램 수정이 쉬워진다.

유연성이 있으면서 당장 이득을 얻을 수 있는 패턴을 사용. 앞으로 이득을 얻을 수 있을지 불확실한 패턴의 경우에는 사용을 보류했다가 정말 필요할 때 사용하라.

유연성은 복잡성을 증가 -> 위의 프로퍼티 예
단순성은 유연성을 증가 -> 프로퍼티를 사용하는 옵션을 제거하면 단순해지면서 프로그램 수정이 용이해진다.

#### 원칙
원칙을 이해하고 있다면, 패턴을 사용하는 근본적인 이유에 대해 알 수 있으므로 새로운 상황에 부딪혔을 때 적절히 대처할 수 있고, 새로운 패턴을 만들수 있다.

##### 지역적 변화
코드를 수정할 때 함께 바꿔야 하는 부분을 최소화하라. - 프로그램 수정비용 최소화

##### 최소 중복

중복은 실제 코드에 나타나기 전까지 예측하기 어렵고, 발생한 후에도 그 존재가 분명치 않다. 어떤 경우는 중복을 제거하기 어려울 수도 있다. 
-> 중복을 절대로 피해야할 요소로 보기보다는 코드 수정 비용을 높이는 위험 요소로 보는 것이 좋다.

중복을 없애는 방법
프로그램을 여러 작은부분으로 나눈기.(짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지)

##### 로직과 데이터의 결합
데이터와 (그 데이터를 처리하는) 로직을 밀접하게 배치하라
(가급적 같은 메소드 혹은 같은 객체 내에, 최소한 같은 패키지 내부에)
프로그램을 수정할때 로직과 데이터를 모두 고쳐야 할 경우가 많다. 따라서 로직과 데이터가 함께 있다면 프로그램을 수정하더라도 그 영향이 일정 영역에 머물게 된다.

##### 대칭성(symmetry)
대칭적인 존재. ex) add() <-> remove(), 같은 파라메터를 쓰는 여러 개의 메소드
대칭성을 찾아내면 명확하게 표현해주면 상대적인 코드는 쉽게 이해가 가능하기 때문에 가독성이 증가된다.

대칭성이란 시각적으로 표현할 수 없는 개념적인 대칭성일 경우가 많다.
대칭성이란 하나의 아이디어를 프로그램 전체에서 일관된 방식으로 표현하는 통일성이라고 할 수 있다

대칭성을 찾아서표 표현하면 코드의 중복을 제거할 수 있다. 

##### 선언적 표현
명령형 프로그래밍(imperative programming)에서는 프로그램의 수행흐름을 따라가야한다. 즉, 컴퓨터의 수행 상태를 생각하면서, 제어 흐름과 데이터 흐름을 추적해야 프로그램을 제대로 이해할 수 있다.
수행 순서가 중요한 구문이나 조건부 구문이 없는 일반 구문의 경우, 선언적 표현을 통해 코드를 작성하는 것이 이해가 쉽다.

##### 변환율
변환율이 다른 로직과 데이터는 분리.
변환율은 대칭성의 일종으로 시간적 대칭성이다. 
(value, currency -(변하는 부분은 도우미 객체 사용)> new Money(value, currency))
value, currency는 대칭적으로 함께 변하지만 객체내의 다른 필드와는 대칭적이지 않다.
(-_-?)

### 04 동기유발
전체 비용 = 개발 비용 + 유지 비용
이 책은 유지 비용이 많이 드는 상황에서 적용. 유지 비용이 거의 들지 않는 프로젝트라면 다른 종류의 패턴 사용 권유한다.

유지 비용 = 이해 비용 + 수정 비용 + 테스트 비용 + 설치 비용

구현 패턴이 습관화 되면 -> 처음엔 힘들지만...개발이 더 빨라지고 코드 이해가 쉬워져 커뮤니케이션 증가. -> 유지 비용 절감 효과.(코더가 왜 비용 측면에 관심은...흠...나랑 급이 다른갑다 -_-;;)

### 05 클래스

	클래스의 역사는 플라톤이 살았던 시대까지 거슬러 올라간다. 플라토은 현실 세계에 존재하는 것은 클래스의 인스턴스(instance)일 뿐이라고 이야기했다. 플라톤 세계의 클래스는 완벽하지만 현실적이지 못하고, 현 세계에 있는 인스턴스는 존재하기는 하지만 어딘가 불완전하다.
    (오 대박 나도 이런 생각했었는데...감동 ㅋㅋ)

클래스와 객체는 후기 서양 철학의 아이디어를 받아들여서 프로그램을 콜래스와 객체로 구성한 것이다.
클래스: 비슷한 성질을 가진 것을 총칭
객체: 클래스가 구체화된 것

- 클래스: "이 데이터 들은 함께 사용되는데 그에 관련된 로직이 이것이다"라는 이야기를 하고 싶을 때 클래스를 사용한다.
- 단순한 상위클래스 이름: 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다.
 간결성과 표현성 사이에서 고민인 경우는 은유(metaphor)사용 - ex: DrawingObject -(Drwaing은 책의 페이지와 비슷하고 페이지의 각 항목은 그림)-> Figure 
- 한정적 하위클래스 이름: 상위클래스와의 유사점과 차이점을 분명히 드러내는 이름을 사용한다.
클래스 게층의 최상의 클래스와 같은 역할을 하는 하위 클래스에는 단순한 이름을 선택해야한다.
ex) Figure -> ** Handle** -> StretchHandle, TransparencyHandle
- 추상 인터페이스: 인터페이스와 구현을 분리한다.
인터페이스: 구현이 빠진 여러 연산의 집합, 인터페이스를 사용한다면, 구상 클래스(concrete class)를 나중에 얼마든지 바꿀수 있다. 구상 클래스는 컴퓨터가 실제 연산을 하기 전에만 결정하면 된다.
인터페이스 추가에는 비용이 발생되므로 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 사용.
- 인터페이스: 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
자바 인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다"와 같다.
네이밍 원칙2(둘다 객체가 추상인지 구상 객체인지 전달하는게 포인트)
인터페이스는 간결하게 구상 클래스에 구상객체인지 전달. - File - ActualFile, ConcreteFile, FileImpl
구상 클래스를 간결하게 짓고 인터페이스에 I등을 붙이는 방법 - IFile - File
- 버전 인터페이스: 하위 인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다.
인터페이스를 바꾸고 싶고 기존 구현 클래스를 수정하고 싶지 않을때.
```java
interface Command {
  void run();
}
...
interface ReversibleCommand exntends Command {
  void undo();
}
...
Command recent = ...;
if(recent instanceof ReversibleCommand) {
  ReversibleCommand downcasted = (ReversibleCommand) recent;
  downcasted.undo();
}
```
instanceof를 사용하면 코드가 특정 클래스에 제한되므로 유연성이 떨어진다. 버전(대체) 인터페이스는 달갑지 않은 문제에 대한 달갑지 않은 해결책임이다. 확장할 수 없어서 어쩔수 없는 경우 사용
- 추상 클래스: 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
상위 클래스가 런타임에 어떤 하위 클래스로 교체 될지 모른다는 의미에서 추상적이다.
인터페이스는 수정에 비용이 크다, 하지만 추상클래스는 기존 설계를 망가트리지 않고 기본 구현을 사용할 수 있어서 새로운 연산을 추가하기 용이하다.
- 값 객체: 산술 값처럼 동작하는 객체를 사용한다.
자바의 기본형 타잎은 수학적 세계에 속한다(함수형이다). 예를들어, 숫자에 숫자를 더하는 경우 값이 변하는게 아니고 새로은 값을 만든다.
함수형스타일 연산은 상태를 변화시키지 않으며 새로운 값을 생성. 일시적이더라도 고정적인 상황을 표현하고 싶다면 함수형 스타일이 적절하고, 상황이 변하는 경우라면 상태(state)를 사용하는 편이 낫다.
프로시저 인터페이스는 함수 인터페이스에 비해 자주 사용되지만 호출순서가 인터페이스의 일부가 된다. 프로시저 호출 순서에 대한 묵시적 인터페이스가 변경될 경우, 겉보기에 변화가 예측하기 어려운 많은 문제점을 가져온다.
함수형(수학적표현법)의 장점은 순서가 문제가 되는 경우가 드물다는 것. 
????----------------수학적 표기법은은 코드 한줄 한줄이 참이다.작은 수학의 세계를 만든후, 변화하는 상태를 갖고 있는 객체를 통해 관리하는 것이 좋다.-----------------------????
```java
class Transaction {
    int value;
    Transaction(int value, Account credit, Account debit) {
      this.value = value;
      credit.addCredit(this);
      debit.addDebit(this);
    }
}
```
값 스타일 객체(변화하는 상태를 지닌 객체가 아닌 정수와 같은 객체)를 구현하려면, 상태를 가지고 있는 세계와 값으로만 구성된 세계를 구별해야한다.
위의 예에서 Transcation은 값 스타일 객체이고 Account는 변화하는 상태를 가진 객체이다.
값스타일의 객체에서는 생성자에서만 모든 상태를 설정해야한다.
값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다.
-> 값 스타일 객체를 사용할 때의 문제점은 성능이다.
- 특화: 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다.
코드 가독성 증가, 기존 코드가 새로운 요구사항을 처리할 수 있는지 판단할 수 있다.
연산간의 유사점과 차이점을 부각시키는 방향으로 코드를 작성하면, 프로그램을 읽고 사용하고 수정하기 쉬워진다.
(간단한 변형 - 상태만 변경, 복잡한 변형 - 로직 자체를 바꾸는 것)
로직과 데이터의 경계가 분명하지 않다. 플래그는 boolean이지만 제어흐름에 영향을 미치고, 도우미 객체는 필드에 저장할 수 있다.
- 하위클래스: 1차원적 변환은 하위클래스를 사용해서 표현한다.
"이 객체는 상위 클래스와 같다. 이 부분만 제외하면..."이라는 의미와 같다.
상속을 사용할때 문제점
하위 클래스를 되돌리기가 쉽지 않다.
하위 클래스를 이해하기 위해서는 상위 클래스를 이해해야한다.
하위 클래스가 상위클래스 세부 구현 특성에 의존할 수 있으므로 상위클랫의 수정이 위험해진다.
클래스 상속 계증이 복잡해지면서 위의 모든 문제가 심화된다.
병렬 클래스 계층을 사용하는 경우 클래스 계층간 암묵적 의존관계를 형성하게된다.(두개의 상위 클래스가 있는 경우 각각의 상위 클래스는 하위클래스가 있게 된다. 이 하위 클래스는 다른 클래스 계층에 대응되는 상황이 만들어진다.) 이는 일종의 중복이다.
하위 클래스를 올바르게 사용하기 위한 키 포인트는 상위클래스의 로직을 여러개의 메소드로 잘개 쪼개는 것.
상위클래스 메소드가 너무 크다면, 상위 클래스의 메소드를 복사해서 수정한다. 하지만 이러는 경우는 상위/하위 클래스간 암묵적 의존 관계가 생긴다. 이 경우 유지보수에 문제가 생기므로 신중을 가해야한다.
하위 클래스는 동적으로 변화하는 로직을 나타낼 수 없기 때문에, 객체를 생성할 때 그 객체의 목적을 알아야 하며 이는 이후에 바뀔 수 없다. 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용.
- 구현자(implementor): 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다.
(내용이 구현자란 주제하고 생뚱맞는 느낌은...)
객체지향 프로그램에서는 선택을 표현하기 위해 주로 다형적 메시지(polymorphic message)를 사용.
프로시저 표현에 비해 객체와 메시지를 사용하는 방식은 프로그래머의 의도와 구현을 분리해서 좀더 명확히 프로그래머의 의도를 나타낸다. 그리고 미래에 발생된 확장에대해서도 수용할 수 있게 되었다. -> 표현의 명확성과 유연성을 통해 객체 지향 언어는 프로그래밍 언어의 패러다임을 교체했다.
- 내부 클래스: 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다.
간단히 상위 클래스를 약간 수정하는 경우 유용
내부 클래스를 감싼 클래스(enclosing case)에 대한 정보를 암묵적으로 전달 받는다. 이는 클래스간의 관계를 명시적으로 정하지 않으면서도 감싼 클래스의 데이터를 접근할 수 있는 기법이다.
```java
public class InnerClassExample {
	private String field;
    public class Inner {
    	public String example(){
        	return field;
        }
    }
    @Test publicvoid passes() {
    	field = "abc";
        Inner bar = new Inner();
        assertEquals("abc", bar.example());
    }
}
```
위의 경우 내부 클래스를 명시적으로 선언하는 경우에도 인자 없는 생성자를 가질 수 없다.(why????????????????????????) 리플렉션을 사용해서 인스턴스를 만든다면 내부 클래스의 이러한 점이 문제가 될 수 있다.

```java
public class InnerClassExample {
    public class Inner {
        public Inner() {}
    }

    @Test(expected = NoSuchMethodException.class)
    public void innerHasNoArgConstructor() throws Exception {
//       Inner.class.getConstructor(null);
        Inner.class.getConstructor(new Class[0]);
    }

}
```

생성클래스의 인스턴스와 완전히 분리된 내부 클래스를 사용하려면, 내부 클래스를 static으로 선언하면 된다.
- 인스턴스별 행동(instnace-specific behavior): 인스턴스에 따라 로직에 변화를 준다.
비추!! 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 편이 좋다.(커뮤니케이션등 비용이 커진다.)
- 조건문: 명시적 조건에 딸 로직에 변화를 준다.
조건문의 수가 많을수록 프로그램의 안정성이 떨어지는 경향이 있다.
ex)
```java
public void display() {
	switch(getType()) {
    	case RECTANGLE:
        .....
    }
}
public boolean contains(Point p) {
	switch(getType()){
    	case RECTANGLE:
        ...
    }
}
```
위의 예처럼 코드의 암묵적으로 의존성이 발생된다.(하나를 수정하면 다른것도 수정. 다른 개발자에게도 해당 내용을 전체적으로 공유해야하는 문제가 발생)
이 문제는 하위 클래스나 위임을 사용해 조건문을 메시지로 바꾸면 해결 할 수 있다.
중복되는 조건부 로직이나 분기문의 결과에 따라 로직이 달라지는 경우, 보통 명시적인 로직 대신 메시지를 사용하는 것이 좋다. 또한 자주 변하는 조건부 로직의 경우 메시지를 사용하면 다른 분기문에 대한 영향을 최소화하면서 분기문을 단순화할 수 있다.
조건문은 단순성과 지역성(하나의 클래스만 수정)에 장점이 있지만 광범위하게 사용되는 경우 문제가 될 수 있다.
- 위임(delegation): 여러 종류의 객체 중 하나에 위임해서 로직에 변화를 준다.
각 인스턴스에서 다른 로직은 수행하도록 하는 방법으로는 위임(몇 가지 객체 중 하나를 선택해서 작업을 미루는 것)이 있다.

```java
public void mouseDown() {
	switch(getTool()) {
    	case SELECTING : 
            //...
            break;
        case EDITING_TEXT:
        	//...
            break;
        default: break;
    }
}
```
```java
public void mouseDown() {
	getTool().mouseDown();
}
```
새로운 툴을 추가해도 기존 코드를 수정해야하고, 조건문의 중복등으로 인해 도구를 새로 추가하기가 어렵다.(mouseUp(), mouseDown()... hm..............)
메소드가 여러 클래스에 분산되어 구현되므로 코드 읽기는 어려워 졌다.
- 플러그인 선택자(pluggable selector): 리플렉션을 이용한 메소드 호출로 로직에 변화를 분다.
한두 개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스 안에 들어가도 좋은 경우 사용.

```java
String name;
public void runTest() throws Exception {
	Class[] noArguments = new Class[0];
    Method method = getClass().getmethod(name, noArguments);
    method.invoke(this, new Object[0]);
}

```
플러그인 선택자 사용에 따르는 비용은 상당하므로, 그 비용을 정당화 할 수 있는 일부 어려운 문제에만 제한적으로 사용해야 한다.
- 익명 내부 클래스: 필요한 메소드에서 한두 개의 메소드만 오버라이드하는 객체를 만들어서 사용한다.
API가 매우 간단하거나 상위 클래스가 대부분의 구현을 담당하고 있어 내부 클래스를 쉽게 구현할 수 있을때 효과적, 익명 내부 클래스를 사용하는 클래스를 읽는데 방해가 되므로 가급적 짧아야 한다.
단점.
인스턴스에서 사용할 코드가 어떤 것인지 알고 있어야한다.
인스턴스 생성 후에는 수정할 수 없다.
별도로 테스트하기 어려워 복잡한 로직에 적합치 않다.
클래스 이름을 사용할 수 없으므로 이를 통해 프로그래머의 의도를 전달할 수 없다.
- 라이브러리 클래스: 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.
단점.
메소드 수가 많아질 경우 
모든 로직을 정적 메소드로 구현하면 객체지향 프로그래밍의 가장 큰 장점(공유데이터를 전용 네임 스페이스를 사용하여 표현해서 로직은 단순화하는것 <-이게 왜 가장 큰 장점이지???)을 잃게 되므로 가능하면 라이브러리 클래스는 객체로 변환하는 것이 좋다.

라이브러리 클래스를 점진적으로 객체로 바꾸기 위해서는 정적 메소드를 인스턴스 메소드로 바꾸면 된다. 처음에는 정적 메소드가 인스턴스 메소드에 위임하는 방식을 사용해서 같은 인터페이스를 유지하는 것이 좋다.










