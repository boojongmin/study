T-T 12page까지 작업한거 날려먹음. T-T
간략 내용.
# 소프트웨어 설계의 고고학
##### 의존관계
##### 높은 응집도와 낮은 결합도
##### 5대 원칙 정리
1. 단일 책임의 원칙(SRP; Single Responsibility Principle)
 - 객체는 하나의 책임만을 맡아야 한다.
 책임: 클래스에 할당된 비지니스 로직에 대한 요구.
    note
    리팩토링 기법 책임 분배.

2. 의존 관계 역전의 원칙(DIP; Dependency Inversion Principle)
 - 클라이언트는 구체 클래스가 아닌 인터페이스나 추상 클래스에 의존해야한다.

    note
    상속구조에서 하위 클래스를 사용하는 경우
    1. 개발자의 부주의: List list = new ArrayList 대신 ArrayList list = new ArrayList();
    2. 상속구조 자체가 잘못: is a 관계가 아닌데 사용하는 경우(has a는?)
    3. 상속 구조가 LSP를 지키고 있지 않은 경우.: LSP 를 어기고 상속 구조의 폭주를 막기 위해서일 수 있다.(ex: Collections.unmodifiable(List list))
3. 인터페이스 분리의 원칙(ISP; Interface Segregation Principle)
 - 클라이언트에 특화된 여러 개의 인터페이스가 하나의 범용 인터페이스보다 낫다.
4. 리스코프 대체 원칙(LSP; Liskov Substitution Principle)
 - 기반 클래스는 파생 클래스로 대체 가능해야한다.

5. 개방 폐쇄 원칙(OCP; Open-Closed Principle)
 - 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.

##### 아키텍처, 디자인, 마이크로 패턴

표 0-1 패턴 시스템

d|아키텍처|디자인|이디엄
-|-|-|-
From Mud to Structure|Layers, Pipes and Filters, Blackboard| |
Distrubuted System | Broker, Pipes and Filters, Microkernel||
Interactive System| MVC, PAC, ||
Adaptable System | Microkernel, Reflection ||
Structural Decomposition||Whole-Part|
Organization of Work||Master-Slave|
Access Control||Proxy|
Management||Command Processor, View Handler|
Communication||Publisher-Subcriber, Forwarder-Reciever, Client-Dispatcher-Server|
Resource Handling|||Counted Pointer



그림 0-11) MVC 아키텍처 패턴과 MVC를 위해 사용된 내장 패턴들
핸드폰 이미지(2015.11.18)

MVC 패턴은 SOLID 구현의 대표적인 사례다. 업계 표준이 될만하다 -_-b
(책에서는 DIP를 잘 구현했다고하지만... 스프링에서.. 구현 클래스로...개발을...;; 저자가 룰에 좀 언격한듯.)

### 1. OO와 디자인 패턴 기초 다지기
대자인 패턴 개념 제시: 건축가 크리스토퍼 알렉산더(Christopher Alexander)
(원리는 비슷하지만 전술이 다르기 때문에 건축의 패턴을 컴퓨터 세상에 그대로 적용하는건 문제가 있다고함.)

1995년 GOF - Design Patterns: Elements of Reusable Object-Oriented Software
저자는 이 책을 통해 객체지향의 참 모습을 개발자들이 알게 되었지만 학술적이라 접근이 쉽지 않다고하면 이 책을 쓰게됨.

 ##### 패턴 vs 이디엄
 이디엄 - 패턴이 일상화된것, 특히 언어에 내장되면 이디엄이 된다.  ex) C에서 상속은 패턴이였으나 java에서 extends

##### 디자인 패턴이란 무엇인가?
크리스토퍼 알렉산더 왈 건물을 관찰하면 건물의 어느 특정 측면(ex: 쾌적하다)에 초점을 맞추면 이들 건물에서 특정 패턴이 창발(emergence)하기 시작한다는 것을 발견했다. 특정 측면의 문제들은 유사한 방식으로 해결해가는 경향이 있는데 이게 패턴.

누군가 독립적으로 발명한 해결방식은 패턴이 아니고 디자인이다. 여러 프로젝트에서 반복적으로 발견되어야 패턴이라 할 수 있다.

패턴은 문제에 대한 해결 방법 그 자체라기 보다는 해결 방법의 일반 구조화라 할 수 있다.

패턴의 정적구조(UML)보다는 '패턴의 의도'와 '동적 행동 양식'이 중요하다

1. 문제에 대해 초점을 맞추고 이를 해결한 여러 프로젝트들을 보면 공통적인 '어떤' 패턴이 창발한다. 이 어떤 패턴에 이름을 부여
2. 패턴을 식별하고 패턴이 해결하려는 일반 문제와 이에 대한 해결 방법에 대한 요약을 '의도(intent)'라 부른다. 이 의도를 만족시키면 어떤 구조(디자인)이던 상관없이 이 패턴의 합당한 실체화(reification)이 된다.
(실체화는 의도를 구체적으로 만들수 있는 방법에 대한 생각을 하는 것.)
3. 패턴의 실체화는 구현이 아니라 디자인이다.
4. 디자인은 다양한 코드로 구현(implementation)될 수 있다

       패턴 -> 디자인 -> 코드

ex)
통풍과 조명이라는 두가지 측면에 초점을 맞춘다(뒤에 조명 얘기 나옴.)
->
시원하면서도 안락한 느낌을 주는 방들을 살펴본다.
->
공통적으로 '교차통풍'이라 부른 패턴이 창발
->
이 패턴에 속한 방들은 보통의 창문 높이에서 공기가 유입되는 곳과 공기가 빠져나가는 곳이 서로 마주 보고 있다. 한 곳에서 유입된 공기는 방을 가로지르며 다른 곳으로 빠져 나간다.
->
해결방법에 대한 용약인 '의도'를 작성. 교차통풍의 의도는 '공기가 중간 정도의 높이에서 방을 수평으로 가로지르도록 하여 숨막힘을 없애고, 안락하며 시원한 느낌을 주도록 한다.'
-> 패턴에 합당한 실체화를 한다.
->
실체화
1. 창을 서로 마주보게
2. 문을 서로 마주보게
3. 창과 문을 서로
4. 통풍기를 양쪽에
5. 마주 보는 벽을 아예 뚫는다.
6.........................(방법은 많다.)
   - 공기의 유입구와 출입구가 모두 같다면 교차통풍의 실체화가 아니다. 저자는 천장에 통풍구가 있는 빌딩이 별로라고 한다 ㅎㅎ

(정리)
교차통풍 패턴의 의도: 공기가 중간 정도의 높이에서 방을 수평으로 가로지르도록하여 숨막힘을 없애고, 안락하며 시원한 느낌을 주도록한다.
패턴의 참여자: 창, 문, 없는 벽.......
참여자의 역할: 공기의 유입구와 출구.


조명
조명이 쾌적한 방
-> 두벽에 창이 있음.
-> 여러 방향에서 자연광이 방을 조명 쾌적
-> 코너 오피스라 부름
-> 의도는 '인접한 두 벽에서 자연광이 들어올 수 있도록 하여 방을 쾌적하게 만든다.'
-> 수많은 방법으로 실체화

그림1-1) 핸드폰 이미지 2015.11.18

그림에서 코차통풍과 코너오피스 패턴 모두 패턴에 참여. 패턴은 고립된게 아니고 두
개 이상의 패턴을 함께 사용하는 경우가 많다.

중요한것은, 구조만으로 패턴을 파악하는 것은 불가능하다. 예를 들면 창문이 하나가 다른 건물에 의해 막힐 수도 있고 통풍구 겸 창문이가 되어야할 것의 밖은 복도일 수 있다. 이런 경우는 코너오피스를 만족시키지 못한다.... 즉, 프로그램에서 디자인 패턴을 찾아내려면 아키텍처의 의도를 포함은 무맥정보가 필요하다.

  구조만으로 패턴을 파악하기는 어려우며 항상 의도를 함께 보아야 한다.


##### 패턴 무엇이 좋은가.
의사소통의 경제성
디자인의 경제성

패턴은 보통 구현 단계에 고민한다.
디자인 패턴은 보통 디자인 문서에 나타나지 않으며, 구현 레벨에서 프로그래머가 사용한다.
매우 복잡한 시스템의 경우는 패턴을 디자인 문서에 상세히 기술하기도 한다.

##### 패턴과 단순함 사이의 긴장
패턴 단점: 모든 곳에 패턴을 사용하려하면 오히려 시스템의 복잡성을 증대시킨다. 적절히!!
시스템은 단순하게
미래를 예측하려하지 말고 지금하는 코드를 수정하기 쉽게 프로그램을 작성.
지나치게 단순함을 위해 필요한 프로그램의 완정성을 희생하면 안된다.(Undo가 구현이 복잡하니 문자를 지울때 경고창을 나오게 -> 사용자가 얼마나 짜증날까?)

단순함, 완전성, 수정의 용이성은 경험과 학습을 통해 올바른 선택 능력을 키워나가야한다.

저자는 인터페이스를 적극적으로 사용하자고 한다. 사용해서 복잡성 증가는 적은대신 기능 변경이나 추가시 리팩토링이 쉬워진다고함. (엥? 진짜????????? -_-??)

##### 패턴 분류하기
패턴 분류 기준은 여러가지임 일단 GOF의 방식을 따름.
 - 분류1
  - 객체 패턴
  - 클래스 패턴
 - 분류2
  - 생성 패턴(Creational Pattern): 생성과 관련한 문제
  - 구조 패턴(Structural Pattern): 정적 모델 패턴으로 프로그램의 구조적 구성
  - 행위 패턴(Behavioral Pattern): 동적 모델 패턴으로 런타임 시에 상호 작용하는 객체들 간의 문제

다른 패턴 분류 기준 -> 실시간 프로그래밍 패턴, 스레드 패턴, 자바 엔터프라이즈 자바빈즈 패턴.....(많네....)  

 | | | 목적| |
 -|-|-|-|-|
 | | 생성| 구조|행위
영역|클래스|Factory Method| Class Adapter| Interpreter, Template Method
 |객체|Abstract Factory, Builder, Prototype, Singleton|Bridge, Composite, Decorator, Facade, Flyweight, Object Adapter, Proxy| Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Visitor

    note
    패턴은 고립된 섬이 아니다. 이들은 서로 연관되어 있으며, 함께 사용하는 경우가 많다.

패턴들간을 구분하기 힘들다면 패턴의 의도 혹은 목적에 초점을 맞춰라.
보통은 패턴의 목적(의도)가 아닌 UML에 표현된 정적 구조만 본다. <- 문제점

OOD(Object-Oriented Design) vs OOP(Object-Oriented Programming)
둘의 차이를 인지하는건 중요하다.
디자인은 유스케이스를 분석 등을 통한 요구사항 수집에서 시작해 코딩이 시작되는 디자인으로 끝난다.
즉, 개발 경력이 많다고하더라도 OOP를 잘하는 것이지 항상 OOD를 잘한다고 볼 수 없다.

    건축 설계자 vs 시공자(노가다)이라고 생각하면... ㅎㅎ

##### 자바를 C언어 스타일로 프로그래밍하기
- 절차 지향: 데이터중심(datacentric)
  데이터를 조작 혹은 검토하는 서브루틴 간의 데이터 흐름을 구조화

  데이터베이스가 프로그램의 디자인의 중심이 된다

  계층구조가 깊고 큰 경향이 있으며, '전역 제어'가 주를 이름

  최대의 단점은 디버깅 및 유지보수가 어렵다.
  - 공유된 데이터는 '결합(coupling)' 관계를 생성한다.
  - 서브루틴간의 의존성이 높아 하나의 서브루틴을 수정시 다른 곳에 장애를 발생시켜 수정이 길어질 수 있다.

(객체지향은 내용이 좋아서 그대로 작성)
- 객체지향:  상호 협동하는 에이전트들의 네트워트이며, 에이전트는 메시지를 통해 통신한다. 객체들은 평등하며 단른 객체에 명령을 내리는 귀족 객체는 드물다.

 우선 객체를 외부에서 보았을 때 객체가 어떻게 구현되었는지를 알 수 있으면 안 된다. 이 원리르 ㄹ지키며 객체를 이용하고 있는 클라이언트 객체에 아무런 영향을 미치지 않으면서 전체 구현을 바꾸는 것도 가능하다. 때때로 객체가 어떤 객체를 다른 객체에 넘겨주기도 하지만, 이것은 절차 지향적 관점에서 데이터가 흐르는 것과는 다르다. 객체는 외부 객체를 경계하며 자신의 데이터를 보호하며, 외부 객체에 공개된 인터페이스를 통해 받은 메시지에 응답해 데이터에 특정 연산을 수행한다. 객체는 꼭 필요한 경우가 아니면 다른 객체에 데이터를 넘겨주지 않으며, 데이터 자체는 다른 객체가 알 수 없도록 캡슐화되어 있다. 이 두 개념(**구현은닉**과 **데이터 추상화**)이 핵심이다.

 객체 지향 시스템과 절차지향 시스템을 구분하는 한 가지 좋은 방법은 -> 무엇인가를 변화시킬 때 어떤 일이 발생하는가를 보는 것이다. 절차 지향 스스템에서는 변화가 프로그램의 나머지에 '퍼지나가는' 경향이 있다.보통 행동을 크게 변화시키면 코드 전반에 걸친 수정이 필요하다.반면 객체지향 시스템에서는 변화가 한곳에 집중되는 경향이 있다. 또한 코드의 한 부분만 변화시켜도 시스템 전체의 행동을 크게 변화시킬 수 있다.


##### 열린 눈으로 프로그래밍하기
     디자인의 선택은 트레이드 오프, 리스크 관리의 연속이다.
     어떤 선택의 좋고 나쁨은 상대적인 것이며 전체 기준의 맥락 안에서 신중히 판단해야 한다.

어떤 기능 혹은 이디엄이 초래할 수 있는 폐해를 이해하자 그러면 그것들을 사용하는 것이 적절한지 아닌지 현명하게 판단 가능해진다.
선택과 결정은 정보에 근거해야하고 실용적이어야한다. <- 저자는 이런 생각을 가졌군... 나쁘지 않네
특정 기술에 함몰되지 말고 열린 눈으로 바라 보자.

##### 객체란 무엇인가?
##### 허튼 소리
c++ 창시자 비잔 스트로스트럽 -> OOP 비난 : 상투적 전문 용어 지향 프로그래밍
저자는 비잔 스트로스트럽을 비난

객체: 런타임, 객체들은 메세지를 통해 통신, 통신을 받은 객체는 행동
클래스: 컴파일러가 제공하는 편의. 런타임이 아니다!
     객체지향 디자인을 하는 것이지 클래스 지향 디자인을 하는 것이 아니다

데이터 추상화: 모든 정보는 감추어야한다. 객체를 동물로 비유하면 동물의 뱃속까지 보고싶은가...?  >_<

따라하기류의 책에서 '객체는 메소드라 불리는 함수가 있는 자료 구조이며 메소드가 자료 구소를 조작한다'하는 소리는 허튼 소리다.

##### 객체는 기능의 집합이다.
객체는 어떻게 하느냐가 아니라 '무엇'을 할 수 있느냐를 통해 정의
객체는 객체들이 서로 주고 받을 수 있는 메시지를 통해 정의. 그리고 이러한 메시지를 처리하는 '메소드'가 외부 세계로의 인터페이스를 구성.
객체가 무엇을 하느냐가 중요하지 어떤 기능을 가졌는지 그 기능이 어떻게 구현되어 있는지가 중요한 것은 아니다. 즉 OOP 디자이너들은 메소드 디자인에 상당한 시간을 들이고 기능을 구현하기 위해 데이터가 필요하겠지만 데이터가 중심에 있고 객체가 데이터를 화장하고 있는 것은 절대로 아니다.

    OO 시스템의 제1 지령
    객체에 어떤 작업을 하는 데 필요한 정보를 요청하지 말라. 대신 작업을 하는데 필요한 데이터를 갖고 있는 객체에 일을 해달라고 요청하라.

켄 아놀드: 정보가 아닌 도움을 요청하라(Ask for help, not information.)
- 객체는 계약에 의해 정의되며, 객체는 그들이 맺은 계약을 위반해서는 안 된다.
- 모든 데이터는  rprivate이어야 한다. 이 법칙은 데이터뿐 아니라 모든 구현 상세에도 적용된다.
- 변화가 아무리 클지라도 객체의 구현 방식, 객체를  정의하는 단 하나의 클래스만을 수정해 반영할 수 있어야한다.
- 부적절히 사용된 'get', 'set' 메소드는 사악하다. 이들은 단지 데이터를 public으로 만들 뿐이다.

계약: 외부에서 보았을 때 어떻게 행동할 것인것을 정의. 객체의 사용자는 시간이 지나더라도 객체의 행동이 변하지 않을 것이라 가정(메소드의 signature는 함부로 변경하면 안된다.). 객체를 구현하는 인터페이스는 계약의 일부. 계약은 성능, 메모리 사용 등의 기타 사항도 포함한다.(?).
구현은 계약의 일부가 아니다. 계약을 근거로 구현은 마음대로 바꿀수 있다.

##### 어떻게 잘못 하고 있는가?

객체 지향 시스템은 보통 절차 지향 시스템보다 복잡하지만 유지보수가 쉽다. 복잡성을 제거하지는 못하지만 조직화하여 관리하기 때문이다.

객체 지향적인 해결 방버은 변화와 확장의 (가능성이 높은) 부분을 캡슐화하려 시도한다. 캡슐화되어 있는 부분에서 변화나 확장이 일어나게 되면 시스템의 다른 부분에는 영향을 미치지 않기 때문.

저자는 MVC 구조에서 너무 많은 데이터가 흘러 다니기 때문에 객체 혹은 컴포넌트 간의 결합도가 높아진다져서 결국 절차적으로 코딩하게 된다 그러면 자바를 쓸 이유는 없다고 문제를 제기함.

##### 어떻게 '올바르게' 할 수 있는가?
(예제를 통해 문제 해결 방법을 보여줌. 많아서 작성이 T-T.)
step1. '문제 도메인' 관점에서 정의한 '문제 기술서'를 작성.
step2. CRC 카드 작성
(사진 20151123 표 1-2)


CRC카드: http://c2.com/doc/oopsla89/paper.html 참조
복잡계: 부분을 떼어 놓고 볼 때는 알 수 없는 특지잉 창발되는 계를 의미. 구성요소들 간의 상호작용을 자기 조직화라 하며, 전체를 보았을 때 어떤 특징이 발현되는 것을 창발(emergence)라 한다. 복잡계 소개: 이머전스(매래와 진화의 열쇠), 공학의 관점에서는 유전자 알고리즘을 창시한 존 홀랜드 '숨겨진 질서' 이 복잡계를 개발 방법론에 적용한 책: Adaptive Software Developement

솰라솰라
솰라솰라
솰라솰라
솰라솰라
솰라솰라
솰라솰라
솰라솰라
가능하면 getter/setter 쓰지마

관계형DB처럼 절차적인 시스템을 사용하기 위해서는 getter/setter 사용이 불가피하다. (응??? 와이?)
솰라솰라
솰라솰라
솰라솰라
솰라솰라
솰라솰라
솰라솰라
솰라솰라

# chapter 2 인터페이스로 프로그래밍하기 그리고 몇 개의 생성패턴
extends는 OO적인 것이 아니다(일부일뿐 주가 아니다.). 다형성이 OO적이다(메인이다). 데이터 추상화(객체안에 구현 상세를 캡슐화하는것) OO적이다.

    고슬링: 구현 상속보다는 인터페이스 상속이 훨씬 바람직하다.

애자일 방법론에서는 디자인과 개발을 병행적으로 진행한다.

디자인과 개발을 병행적으로 진행하려면 새로운 요구 사항을 쉽게 반영할 수 있는 '유연성'이 필수적이다. 단순하고 유연하게!

저자는 OO 개발 방법론은 엄격하게 적용하는 것이 코드를 빨리 작성하고 유지보수를 쉽게 한다고 한다.(really?)

인터페이스 장점
- 유연성 증가
- 결합도 감도
 - 상수를 제외한 모든 필드는 private이어야한다는 명제를 통해 만들 수 있는 데이터 추상화를 지원할 수 있다. 사용하는 객체에게 숨겨야한다.(상속도 private는 안보일텐데?-상속을 쓴다는 것은 부모의 필드를 이용하겠다는 의미가 녹아나있기때문에 private로 하지 않는 것이라 말할 수 있는것인가...? 흠....)
- 깨지기 쉬운 기반 클래스 문제: 부모(기반) 클래스를 수정했을때 자식(파생) 클래스가 잘못 작동하는 경우.
 - Stack을 사용하기 위해 ArrayList를 상속받아 구현했을때 Stack에 정의하지 않은 ArrayList의 clear를 사용했을때? -> 물론 clear에 throw Exception(또는 RuntimeException)을 할 수 있지만 이 것은 LSP
를 위반하게 된다.
 - 부모 코드를 고쳐야하는 상속(오버라디한다면???)보다 하위 위임모델인 구현 인터페이스 킹왕짱, 대신 코드가 길어질 수 있다. 진짜 많으면 유지보수성을 낮추더라도 상속 전략을 쓸 수 있지만 비추.
- 다중상속(자바는 인터페이스를 통해... 다중구현이 아닌가? -_-ㅋ)
```java
interface Base {
  void f();
  static class Implementaion implements Base {
    public void f(){/*...blah blah..*/}
  }
}
class Derived extends Something implements Base {
  Base delegate = new Base.Implmentation();
  public void f(){
    delegate.f();
  }
}
```
- 프레임워크: 상속(파생)기반은 너무 많은 클래스를 만들어 낸다(ex: swing의 paint() 오버라이드를 위해 Component 파생 클래스들)
  저자는 하나의 클래스가 충분히 안정적으로 구현되려면 대략 2~3주(문서화 포함) 걸린다고 한다. 클래스 숫자 증가 뿐만 아니라 계층이 깊어지면 문제가 생기는데, 파생을 통한 커스터마이제이션 전략은 계층이 깊어지면 제대로 동작하지 않는다.
  기본 Editor를 상속받은 EditableTextController, StandaloneEditor가 있는 상태에서 Editor를 커스터마이징해서 updateBuffer란 메서더를 추가한 CustomerEditor가 추가된다면? 이때는 NewEditableTextController, NewStandaloneEditor를 추가로 만들어야할 것이다... Hell...(TemplateMethod패턴을 예로 들면서 설명 기존 Editor를 사용한 파생 클래스는 CustomEditor의 updateBuffer는 사용이 불가.)

  ##### TemplateMethod와 Factory Method 패턴
  template method 패턴은 상속을 기반으로 사용는 패턴. 파생 클래스의 커스터마이징에 의존하는 패턴으로 기반 클래스가 변경되면 깨지기가 매우 쉽다.(저자 비추.)

  
