T-T 12page까지 작업한거 날려먹음. T-T
간략 내용.
# 소프트웨어 설계의 고고학
##### 의존관계
##### 높은 응집도와 낮은 결합도
##### 5대 원칙 정리
1. 단일 책임의 원칙(SRP; Single Responsibility Principle)
 - 객체는 하나의 책임만을 맡아야 한다.
 책임: 클래스에 할당된 비지니스 로직에 대한 요구.
    note
    리팩토링 기법 책임 분배.

2. 의존 관계 역전의 원칙(DIP; Dependency Inversion Principle)
 - 클라이언트는 구체 클래스가 아닌 인터페이스나 추상 클래스에 의존해야한다.

    note
    상속구조에서 하위 클래스를 사용하는 경우
    1. 개발자의 부주의: List list = new ArrayList 대신 ArrayList list = new ArrayList();
    2. 상속구조 자체가 잘못: is a 관계가 아닌데 사용하는 경우(has a는?)
    3. 상속 구조가 LSP를 지키고 있지 않은 경우.: LSP 를 어기고 상속 구조의 폭주를 막기 위해서일 수 있다.(ex: Collections.unmodifiable(List list))
3. 인터페이스 분리의 원칙(ISP; Interface Segregation Principle)
 - 클라이언트에 특화된 여러 개의 인터페이스가 하나의 범용 인터페이스보다 낫다.
4. 리스코프 대체 원칙(LSP; Liskov Substitution Principle)
 - 기반 클래스는 파생 클래스로 대체 가능해야한다.

5. 개방 폐쇄 원칙(OCP; Open-Closed Principle)
 - 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.

##### 아키텍처, 디자인, 마이크로 패턴

표 0-1 패턴 시스템

d|아키텍처|디자인|이디엄
-|-|-|-
From Mud to Structure|Layers, Pipes and Filters, Blackboard| |
Distrubuted System | Broker, Pipes and Filters, Microkernel||
Interactive System| MVC, PAC, ||
Adaptable System | Microkernel, Reflection ||
Structural Decomposition||Whole-Part|
Organization of Work||Master-Slave|
Access Control||Proxy|
Management||Command Processor, View Handler|
Communication||Publisher-Subcriber, Forwarder-Reciever, Client-Dispatcher-Server|
Resource Handling|||Counted Pointer



그림 0-11) MVC 아키텍처 패턴과 MVC를 위해 사용된 내장 패턴들
핸드폰 이미지(2015.11.18)

MVC 패턴은 SOLID 구현의 대표적인 사례다. 업계 표준이 될만하다 -_-b
(책에서는 DIP를 잘 구현했다고하지만... 스프링에서.. 구현 클래스로...개발을...;; 저자가 룰에 좀 언격한듯.)

### 1. OO와 디자인 패턴 기초 다지기
대자인 패턴 개념 제시: 건축가 크리스토퍼 알렉산더(Christopher Alexander)
(원리는 비슷하지만 전술이 다르기 때문에 건축의 패턴을 컴퓨터 세상에 그대로 적용하는건 문제가 있다고함.)

1995년 GOF - Design Patterns: Elements of Reusable Object-Oriented Software
저자는 이 책을 통해 객체지향의 참 모습을 개발자들이 알게 되었지만 학술적이라 접근이 쉽지 않다고하면 이 책을 쓰게됨.

 ##### 패턴 vs 이디엄
 이디엄 - 패턴이 일상화된것, 특히 언어에 내장되면 이디엄이 된다.  ex) C에서 상속은 패턴이였으나 java에서 extends

##### 디자인 패턴이란 무엇인가?
크리스토퍼 알렉산더 왈 건물을 관찰하면 건물의 어느 특정 측면(ex: 쾌적하다)에 초점을 맞추면 이들 건물에서 특정 패턴이 창발(emergence)하기 시작한다는 것을 발견했다. 특정 측면의 문제들은 유사한 방식으로 해결해가는 경향이 있는데 이게 패턴.

누군가 독립적으로 발명한 해결방식은 패턴이 아니고 디자인이다. 여러 프로젝트에서 반복적으로 발견되어야 패턴이라 할 수 있다.

패턴은 문제에 대한 해결 방법 그 자체라기 보다는 해결 방법의 일반 구조화라 할 수 있다.

패턴의 정적구조(UML)보다는 '패턴의 의도'와 '동적 행동 양식'이 중요하다

1. 문제에 대해 초점을 맞추고 이를 해결한 여러 프로젝트들을 보면 공통적인 '어떤' 패턴이 창발한다. 이 어떤 패턴에 이름을 부여
2. 패턴을 식별하고 패턴이 해결하려는 일반 문제와 이에 대한 해결 방법에 대한 요약을 '의도(intent)'라 부른다. 이 의도를 만족시키면 어떤 구조(디자인)이던 상관없이 이 패턴의 합당한 실체화(reification)이 된다.
(실체화는 의도를 구체적으로 만들수 있는 방법에 대한 생각을 하는 것.)
3. 패턴의 실체화는 구현이 아니라 디자인이다.
4. 디자인은 다양한 코드로 구현(implementation)될 수 있다

       패턴 -> 디자인 -> 코드

ex)
통풍과 조명이라는 두가지 측면에 초점을 맞춘다(뒤에 조명 얘기 나옴.)
->
시원하면서도 안락한 느낌을 주는 방들을 살펴본다.
->
공통적으로 '교차통풍'이라 부른 패턴이 창발
->
이 패턴에 속한 방들은 보통의 창문 높이에서 공기가 유입되는 곳과 공기가 빠져나가는 곳이 서로 마주 보고 있다. 한 곳에서 유입된 공기는 방을 가로지르며 다른 곳으로 빠져 나간다.
->
해결방법에 대한 용약인 '의도'를 작성. 교차통풍의 의도는 '공기가 중간 정도의 높이에서 방을 수평으로 가로지르도록 하여 숨막힘을 없애고, 안락하며 시원한 느낌을 주도록 한다.'
-> 패턴에 합당한 실체화를 한다.
->
실체화
1. 창을 서로 마주보게
2. 문을 서로 마주보게
3. 창과 문을 서로
4. 통풍기를 양쪽에
5. 마주 보는 벽을 아예 뚫는다.
6.........................(방법은 많다.)
   - 공기의 유입구와 출입구가 모두 같다면 교차통풍의 실체화가 아니다. 저자는 천장에 통풍구가 있는 빌딩이 별로라고 한다 ㅎㅎ

(정리)
교차통풍 패턴의 의도: 공기가 중간 정도의 높이에서 방을 수평으로 가로지르도록하여 숨막힘을 없애고, 안락하며 시원한 느낌을 주도록한다.
패턴의 참여자: 창, 문, 없는 벽.......
참여자의 역할: 공기의 유입구와 출구.


조명
조명이 쾌적한 방
-> 두벽에 창이 있음.
-> 여러 방향에서 자연광이 방을 조명 쾌적
-> 코너 오피스라 부름
-> 의도는 '인접한 두 벽에서 자연광이 들어올 수 있도록 하여 방을 쾌적하게 만든다.'
-> 수많은 방법으로 실체화

그림1-1) 핸드폰 이미지 2015.11.18

그림에서 코차통풍과 코너오피스 패턴 모두 패턴에 참여. 패턴은 고립된게 아니고 두
개 이상의 패턴을 함께 사용하는 경우가 많다.

중요한것은, 구조만으로 패턴을 파악하는 것은 불가능하다. 예를 들면 창문이 하나가 다른 건물에 의해 막힐 수도 있고 통풍구 겸 창문이가 되어야할 것의 밖은 복도일 수 있다. 이런 경우는 코너오피스를 만족시키지 못한다.... 즉, 프로그램에서 디자인 패턴을 찾아내려면 아키텍처의 의도를 포함은 무맥정보가 필요하다.

  구조만으로 패턴을 파악하기는 어려우며 항상 의도를 함께 보아야 한다.


##### 패턴 무엇이 좋은가.
의사소통의 경제성
디자인의 경제성

패턴은 보통 구현 단계에 고민한다.
디자인 패턴은 보통 디자인 문서에 나타나지 않으며, 구현 레벨에서 프로그래머가 사용한다.
매우 복잡한 시스템의 경우는 패턴을 디자인 문서에 상세히 기술하기도 한다.

##### 패턴과 단순함 사이의 긴장
패턴 단점: 모든 곳에 패턴을 사용하려하면 오히려 시스템의 복잡성을 증대시킨다. 적절히!!
시스템은 단순하게
미래를 예측하려하지 말고 지금하는 코드를 수정하기 쉽게 프로그램을 작성.
지나치게 단순함을 위해 필요한 프로그램의 완정성을 희생하면 안된다.(Undo가 구현이 복잡하니 문자를 지울때 경고창을 나오게 -> 사용자가 얼마나 짜증날까?)

단순함, 완전성, 수정의 용이성은 경험과 학습을 통해 올바른 선택 능력을 키워나가야한다.

저자는 인터페이스를 적극적으로 사용하자고 한다. 사용해서 복잡성 증가는 적은대신 기능 변경이나 추가시 리팩토링이 쉬워진다고함. (엥? 진짜????????? -_-??)

##### 패턴 분류하기
패턴 분류 기준은 여러가지임 일단 GOF의 방식을 따름.
 - 분류1
  - 객체 패턴
  - 클래스 패턴
 - 분류2
  - 생성 패턴(Creational Pattern): 생성과 관련한 문제
  - 구조 패턴(Structural Pattern): 정적 모델 패턴으로 프로그램의 구조적 구성
  - 행위 패턴(Behavioral Pattern): 동적 모델 패턴으로 런타임 시에 상호 작용하는 객체들 간의 문제

다른 패턴 분류 기준 -> 실시간 프로그래밍 패턴, 스레드 패턴, 자바 엔터프라이즈 자바빈즈 패턴.....(많네....)  

 | | | 목적| |
 -|-|-|-|-|
 | | 생성| 구조|행위
영역|클래스|Factory Method| Class Adapter| Interpreter, Template Method
 |객체|Abstract Factory, Builder, Prototype, Singleton|Bridge, Composite, Decorator, Facade, Flyweight, Object Adapter, Proxy| Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Visitor

    note
    패턴은 고립된 섬이 아니다. 이들은 서로 연관되어 있으며, 함께 사용하는 경우가 많다.

패턴들간을 구분하기 힘들다면 패턴의 의도 혹은 목적에 초점을 맞춰라.
보통은 패턴의 목적(의도)가 아닌 UML에 표현된 정적 구조만 본다. <- 문제점

OOD(Object-Oriented Design) vs OOP(Object-Oriented Programming)
둘의 차이를 인지하는건 중요하다.
디자인은 유스케이스를 분석 등을 통한 요구사항 수집에서 시작해 코딩이 시작되는 디자인으로 끝난다.
즉, 개발 경력이 많다고하더라도 OOP를 잘하는 것이지 항상 OOD를 잘한다고 볼 수 없다.

    건축 설계자 vs 시공자(노가다)이라고 생각하면... ㅎㅎ

##### 자바를 C언어 스타일로 프로그래밍하기
- 절차 지향: 데이터중심(datacentric)
  데이터를 조작 혹은 검토하는 서브루틴 간의 데이터 흐름을 구조화

  데이터베이스가 프로그램의 디자인의 중심이 된다

  계층구조가 깊고 큰 경향이 있으며, '전역 제어'가 주를 이름

  최대의 단점은 디버깅 및 유지보수가 어렵다.
  - 공유된 데이터는 '결합(coupling)' 관계를 생성한다.
  - 서브루틴간의 의존성이 높아 하나의 서브루틴을 수정시 다른 곳에 장애를 발생시켜 수정이 길어질 수 있다.

(객체지향은 내용이 좋아서 그대로 작성)
- 객체지향:  상호 협동하는 에이전트들의 네트워트이며, 에이전트는 메시지를 통해 통신한다. 객체들은 평등하며 단른 객체에 명령을 내리는 귀족 객체는 드물다.

 우선 객체를 외부에서 보았을 때 객체가 어떻게 구현되었는지를 알 수 있으면 안 된다. 이 원리르 ㄹ지키며 객체를 이용하고 있는 클라이언트 객체에 아무런 영향을 미치지 않으면서 전체 구현을 바꾸는 것도 가능하다. 때때로 객체가 어떤 객체를 다른 객체에 넘겨주기도 하지만, 이것은 절차 지향적 관점에서 데이터가 흐르는 것과는 다르다. 객체는 외부 객체를 경계하며 자신의 데이터를 보호하며, 외부 객체에 공개된 인터페이스를 통해 받은 메시지에 응답해 데이터에 특정 연산을 수행한다. 객체는 꼭 필요한 경우가 아니면 다른 객체에 데이터를 넘겨주지 않으며, 데이터 자체는 다른 객체가 알 수 없도록 캡슐화되어 있다. 이 두 개념(**구현은닉**과 **데이터 추상화**)이 핵심이다.
