# 64비트 멀티코어 OS 원리와 구조

## 3장

####3.1

|운영모드|설명|
|---|---|
|리얼모드|-프로세서의 초기 상태로서 16비트 모드로 동작하며 8086 프로세서와 호환되는 모드.<br>  -최대 1ㅡㅠ(2^20)의 주소 공간을 지원|
|보호모드|-32비트 모드로 동작하며 세그먼트, 페이징, 보호, 멀티태스킹 등의 기능을 제공하는 모드<br>4GB(2^32)의 주소 공간을 지원|
|IA-32e 모드|-32비트 호환 모드와 644비트 모드의 두 가지 서브모드로 구성<br>-보호모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드|
|시스템 관리 모드|-전원 관리나 하드웨어 제어 같은 특수 기능을 제공하는 모드|
|가상8086모드(=Long Mode)|-보호모드내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드|

추가 - p.81 그림 3-1 운영 모드 전환 다이어그램


#### 3.2 운영모드와 레지스터

추가 - p.82, 83 그림 3-2, 그림 3-3 

##### 3.2.1 범용 레지스터(General Purpose Register)
- 운영모드와 관계가 깊은 레지스터
- 계산, 메모리 어드레스 지정, 임시저장 공간 등의 목적으로 사용

범용 레지스터 이름 | 용도
--|--
AX | 산술 연산을 수행할 때 누산기로 사용
BX | 데이터의 어드레스를 지정할 때 데이터 포인터로 사용
CX | 루프 또는 문자열의 카운터로 사용
DX | I/O 어드레스를 지정할 때 사용되며, 산술 연산을 수행할 때 보조 레지스터로 사용
SI | 문자열에 관련된 작업을 수행할 때 원본 문자열의 인덱스로 사용
DI | 문자열에 관련된 작업을 수행할 때 목적지 문자열의 인덱스로 사용
SP | 스택의 포인터로 사용
BP | 스택의 데이터에 접근할 때 데이터의 포인터로 사용
R8~R15 | x86-64 프로세서에서 추가된 범용 레지스터로, 다양한 용도로 사용 가능


main register
    AL/AH/AX/EAX/RAX: Accumulator
    BL/BH/BX/EBX/RBX: Base index (for use with arrays)
    CL/CH/CX/ECX/RCX: Counter (for use with loops and strings)
    DL/DH/DX/EDX/RDX: Extend the precision of the accumulator (e.g. combine 32-bit EAX and EDX for 64-bit integer operations in 32-bit code)
    SI/ESI/RSI: Source index for string operations.
    DI/EDI/RDI: Destination index for string operations.
    SP/ESP/RSP: Stack pointer for top address of the stack.
    BP/EBP/RBP: Stack base pointer for holding the address of the current stack frame.
    IP/EIP/RIP: Instruction pointer. Holds the program counter, the current instruction address.
Segment registers:

    CS: Code
    DS: Data
    SS: Stack
    ES: Extra data
    FS: Extra data #2
    GS: Extra data #3
**wiki참조**
[Purpose](https://en.wikipedia.org/wiki/X86#Purpose)  
[Structure ](https://en.wikipedia.org/wiki/X86#Structure)  

##### 3.2.2 세그먼트 레지스터(Segment Register)
16bit register, 주소 공간을 목적에 따라 구분
(세그먼테이션 메모리관리 기법과 관련 있음)

세그먼트레지스터이름 | 설명
--| --
CS | - 코드 영역을 가리키는 레지스터<br>-데이터 이동 명령으로 값을 변경할 수 없으며, 점프 명령이나 인터럽트 관련 명령으로 변경 가능
DS,ES,FS | -데이터 영역을 가리키는 레지스터<br>- 데이터 이동 명령으로 값을 변경할 수 있음<br>- DS 레지스터는 데이터 영역에 접근할 때 임시적으로 사용됨<br>- ES 레지스터는 문자열과 관련된 작업을 처리할 때 임시적으로 사용됨<br>- 데이터 영역에 접근하면서 DS 레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용
SS| - 스택 영역을 가리키느 ㄴ레지스터<br>- 데이터 이동 명령으로 값을 변경할 수 있음<br>- 스택 관련 레지스터(SP, BP)를 통해 스택에 접근할 때 암시적으로 사용됨

##### 3.2.3 컨트롤 레지스터(Control Register)
운영모드를 변경, 현재 운영중인 모드의 특정 기능을 제어

추가 - p.90 [표 3-5]
추가 - p.91 [그림3-6] 컨트롤 레지스터의 구조

[Control Rgister Wiki](https://en.wikipedia.org/wiki/Control_register)

#### 3.3 운영 모드와 메모리 관리 기법
##### 3.3.1 리얼 모드의 메모리 관리 방식
최대  1MB 주소 사용, segmentation만 지원
segmentation : segment register value * 16 -> segment의 기준 주소로 사용
segment register(16bit) * 16 + general purpose register)

##### 3.3.2 보호 모드의 메모리 관리 방식
segmentation, paging 지원

디스크립터 : 메모리 영역의 정보를 저장하는 자료구조로 GDT(Blobal Descriptor Table)에 위치함.




3.3.3 IA-32e 모드의 메모리 관리 
4장내 PC를 부팅하자 
4.1 부팅과 부트 로더 
4.1.1 부팅과 BIOS 
4.1.2 부트 로더의 역할과 구성 
4.2 부트 로더 제작을 위한 준비 
4.2.1 이클립스 프로젝트 생성 
4.2.2 MINT64 OS의 디렉터리 구조 생성 
4.2.3 makefile 파일 생성 
4.3 부트 로더 제작과 테스트 
4.3.1 세상에서 가장 간단한 부트 로더 
4.3.2 QEMU 실행 
4.3.3 화면 버퍼와 화면 제어 
4.3.4 세그먼트 레지스터 초기화와 Hello, World~! 
4.3.5 부트 로더 테스트 
5장플로피 디스크에서 OS 이미지를 로딩하자 
5.1 BIOS 서비스와 소프트웨어 인터럽트 
5.2 OS 이미지 로딩 기능 구현 
5.2.1 디스크 읽기 기능 구현 
5.2.2 스택 초기화와 함수 구현 
5.2.3 최종 부트 로더 소스 코드 
5.3 테스트를 위한 가상 OS 이미지 생성 
5.3.1 OS 이미지 통합과 QEMU 실행 
2부 64비트 세상으로
6장32비트 보호 모드로 전환하자 
6.1 세그먼트 디스크립터 생성 
6.1.1 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터 타입 설정 
6.1.2 세그먼트의 영역 설정 
6.1.3 기본 오퍼랜드 크기와 권한 설정 
6.1.4 기타 필드 설정 
6.1.5 세그먼트 디스크립터 생성 코드 
6.2 GDT 정보 생성 
6.3 보호 모드로 전환 
6.3.1 프로세서에 GDT 정보 설정 
6.3.2 CR0 컨트롤 레지스터 설정 
6.3.3 보호 모드로 전환과 세그먼트 셀렉터 초기화 
6.3.4 보호 모드용 PRINTSTRING 함수 
6.4 보호 모드용 커널 이미지 빌드와 가상 OS 이미지 교체 
6.4.1 커널 엔트리 포인트 파일 생성 
6.4.2 makefile 수정과 가상 OS 이미지 파일 교체 
6.4.3 OS 이미지 통합 및 QEMU 실행 
7장C언어로 커널 작성하기 
7.1 실행 가능한 C 코드 커널 생성 방법 
7.1.1 빌드 조건과 제약 사항 
7.1.2 소스 파일 컴파일 - 라이브러리를 사용하지 않는 오브젝트 파일 생성 방법
7.1.3 오브젝트 파일 링크 - 라이브러리를 사용하지 않고 특정 어드레스에서 실행 가능한 커널 이미지 파일 생성 방법
7.2 C 소스 파일 추가와 보호 모드 엔트리 포인트 통합 
7.2.1 C 소스 파일 추가 
7.2.2 보호 모드 엔트리 포인트 코드 수정 
7.2.3 makefile 수정 
7.3 커널 빌드와 실행 
7.3.1 이미지 메이커 프로그램 작성 
7.3.2 커널 이미지 생성과 실행 
8장A20 게이트를 활성화하여 1MB이상 영역에 접근해보자 
8.1 IA-32e 모드 커널과 메모리 맵 
8.2 IA-32e 모드 커널을 위한 메모리 초기화 
8.2.1 메모리 초기화 기능 추가 
8.2.2 빌드와 실행 
8.3 1MB 어드레스와 A20 게이트 
8.3.1 A20 게이트의 의미와 용도 
8.3.2 A20 게이트 활성화 방법 
8.4 A20 게이트 적용과 메모리 크기 검사 
8.4.1 A20 게이트 활성화 코드 적용 
8.4.2 메모리 크기 검사 기능 추가 
8.4.3 빌드와 실행 
9장페이징 기능을 활성화하여 64비트 전환을 준비하자 
9.1 선형 주소와 4단계 페이징 기법 
9.2 페이지 테이블 구성과 공간 할당 
9.2.164GB의 물리 메모리 관리를 위한 메모리 계산 
9.2.2 페이지 테이블을 위한 공간 할당 
9.2.3 공통 속성 필드 설정 
9.2.4 페이지 디렉터리 엔트리용 속성 필드 설정 
9.3 페이지 테이블 생성과 페이징 기능 활성화 
9.3.1 페이지 엔트리를 위한 자료구조 정의와 매크로 정의 
9.3.2 페이지 엔트리 생성과 페이지 테이블 생성 
9.3.3 프로세서의 페이징 기능 활성화 
9.4보호 모드 커널에 페이지 테이블 생성 기능 추가 
9.4.1 페이징 기능 관련 파일 생성 
9.4.2 C 커널 엔트리 포인트 수정 
9.5 빌드와 실행 
10장 64비트 모드로 전환하자 
10.1프로세서의 제조사와 IA-32e 지원 여부 검사 
10.1.1 CPUID를 사용하여 프로세서 정보 확인 방법 
10.1.2 프로세서 제조사와 IA-32e 모드 지원 여부 확인 
10.2IA-32e 모드용 세그먼트 디스크립터 추가 
10.2.1 보호 모드 커널 엔트리 포인트에 디스크립터 추가 
10.3IA-32e 모드 전환과 1차 정리 
10.3.1 물리 메모리 확장 기능 활성화와 페이지 테이블 설정
10.3.2 64비트 모드 활성화와 페이징 활성화
10.3.3 IA-32e 모드로 전환과 세그먼트 셀렉터 초기화 
10.3.4 소스코드 1차 정리와 실행 
10.4 IA-32e 모드용 커널 준비 
10.4.1 커널 엔트리 포인트 파일 생성
10.5보호 모드 커널과 IA-32e 모드 커널 통합 
10.5.1 최상위 makefile 수정 
10.5.2 부트 로더 파일 수정 
10.5.3 이미지 메이커 프로그램 수정 
10.5.4 보호 모드 커널의 C 언어 엔트리 포인트 파일 수정 
10.5.5 빌드와 실행 
3부 키보드와 타이머, 인터럽트
11장 키보드 디바이스 드라이버를 추가하자 
11.1키보드 컨트롤러의 구조와 기능 
11.1.1 키보드 컨트롤러, I/O 포트, 레지스터 
11.2키보드 컨트롤러 제어 
11.2.1 키보드와 키보드 컨트롤러 활성화 
11.2.2 IA-32e 모드의 호출 규약 
11.2.3 키보드 컨트롤러에서 키 값 읽기 
11.2.4 A20 게이트 활성화와 프로세스 리셋 
11.2.5 키보드 LED 상태 제어 
11.3 스캔 코드와 간단한 셸 
11.3.1 키보드와 스캔 코드 
11.3.2 스캔 코드를 ASCII 문자로 변환 
11.3.3 간단한 셸 구현 
11.4 키보드 디바이스 드라이버의 통합과 빌드 
11.4.1 키보드 디바이스 드라이버 파일 추가 
11.4.2 어셈블리어 유틸리티 파일 추가 
11.4.3 C 언어 커널 엔트리 포인트 파일 수정 
11.4.4 빌드와 실행 
12장 GDT와 IDT 테이블, TSS 세그먼트를 추가하여 인터럽트를 대비하자 
12.1인터럽트와 예외 
12.1.1 인터럽트와 예외의 차이점 
12.1.2 IDT와 IDT 게이트 디스크립터 
12.1.3 인터럽트와 예외의 종류 
12.1.4 PC 인터럽트의 종류와 발생 원인 
12.2 인터럽트와 예외, 스택과 태스크 상태 세그먼트 
12.2.1 스택 스위칭과 IST 
12.2.2 프로세서와 태스크 상태 세그먼트, 태스크 디스크립터 
12.3GDT 테이블 교환과 TSS 세그먼트 디스크립터 추가 
12.3.1 왜 GDT 테이블을 교환해야 하는가? 
12.3.2 GDT 테이블 생성과 TSS 세그먼트 디스크립터 추가 
12.3.3 TSS 세그먼트 초기화 
12.3.4 GDT 테이블 교체와 TSS 세그먼트 로드 
12.4IDT 테이블 생성, 인터럽트, 예외 핸들러 등록 
12.4.1 IDT 테이블 생성 
12.4.2 IDT 테이블 로드 
12.5IDT, TSS 통합과 빌드 
12.5.1 디스크립터 파일 추가 
12.5.2 어셈블리어 유틸리티 파일 수정 
12.5.3 유틸리티 파일 추가 
12.5.4 C 언어 커널 엔트리 포인트 파일 수정 
12.5.5 빌드와 실행 
13장 PIC 컨트롤러와 인터럽트 핸들러를 이용해 인터럽트를 처리하자 
13.1PIC 컨트롤러 소개 
13.1.1 PIC 컨트롤러란 
13.1.2 PIC 컨트롤러의 구조와 동작 방식 
13.2PIC 컨트롤러 제어 
13.2.1 PIC 컨트롤러 초기화 
13.2.2 인터럽트 입력 선택 
13.2.3 인터럽트 종료 처리 
13.3 인터럽트, 예외 핸들러, 콘텍스트 
13.3.1 임시 핸들러의 문제점 
13.3.2 콘텍스트 저장과 복원 
13.3.3 인터럽트와 예외 핸들러 업그레이드 
13.3.4 IDT 테이블 수정 
13.3.5 인터럽트 활성화와 비활성화 
13.4 PIC 컨트롤러 제어 코드와 핸들러 코드의 통합과 빌드 
13.4.1 PIC 컨트롤러 파일 추가 
13.4.2 ISR 파일 파일 추가 
13.4.3 인터럽트 핸들러 파일 추가 
13.4.4 어셈블리어 유틸리티 파일 수정 
13.4.5 디스크립터 파일 수정 
13.4.6 C 언어 커널 엔트리 포인트 파일 수정 
13.4.7 빌드와 실행 
14장 키보드 디바이스 드라이버를 업그레이드하자 
14.1인터럽트 핸들러와 큐 
14.1.1 인터럽트 핸들러와 어떻게 통신할까? 
14.1.2 큐란 무엇인가? 
14.1.3 범용 큐 설계 
14.1.4 범용 큐 구현과 사용 방법 
14.2 키보드 디바이스 드라이버 업그레이드 
14.2.1 키 정보를 저장하는 자료구조와 큐 생성 
14.2.2 키보드 핸들러 수정 
14.2.3 셸 코드 수정 
14.2.4 인터럽트로 인한 문제와 인터럽트 제어 
14.3 키보드 디바이스 드라이버의 업그레이드와 빌드 
14.3.1 큐 파일 추가 
14.3.2 키보드 디바이스 드라이버 파일 수정 
14.3.3인터럽트 핸들러 파일과 유틸리티 파일 수정 
14.3.4 C 언어 커널 엔트리 포인트 파일 수정 
14.3.5 빌드와 실행 
15장 콘솔 셸을 만들자 
15.1sprintf()와 가변 인자 처

